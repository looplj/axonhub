// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/looplj/axonhub/ent/apikey"
	"github.com/looplj/axonhub/ent/channel"
	"github.com/looplj/axonhub/ent/job"
	"github.com/looplj/axonhub/ent/predicate"
	"github.com/looplj/axonhub/ent/request"
	"github.com/looplj/axonhub/ent/requestexecution"
	"github.com/looplj/axonhub/ent/user"
)

// APIKeyWhereInput represents a where input for filtering APIKey queries.
type APIKeyWhereInput struct {
	Predicates []predicate.APIKey  `json:"-"`
	Not        *APIKeyWhereInput   `json:"not,omitempty"`
	Or         []*APIKeyWhereInput `json:"or,omitempty"`
	And        []*APIKeyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIKeyWhereInput) AddPredicates(predicates ...predicate.APIKey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIKeyWhereInput filter on the APIKeyQuery builder.
func (i *APIKeyWhereInput) Filter(q *APIKeyQuery) (*APIKeyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIKeyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIKeyWhereInput is returned in case the APIKeyWhereInput is empty.
var ErrEmptyAPIKeyWhereInput = errors.New("ent: empty predicate APIKeyWhereInput")

// P returns a predicate for filtering apikeys.
// An error is returned if the input is empty or invalid.
func (i *APIKeyWhereInput) P() (predicate.APIKey, error) {
	var predicates []predicate.APIKey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apikey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIKey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apikey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIKey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apikey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apikey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apikey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apikey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apikey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apikey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apikey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apikey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apikey.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, apikey.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, apikey.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, apikey.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, apikey.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.Key != nil {
		predicates = append(predicates, apikey.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apikey.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apikey.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apikey.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apikey.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apikey.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apikey.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apikey.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, apikey.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, apikey.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, apikey.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, apikey.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, apikey.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apikey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apikey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apikey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apikey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apikey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apikey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apikey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apikey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apikey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apikey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apikey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apikey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apikey.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasUser != nil {
		p := apikey.HasUser()
		if !*i.HasUser {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasUserWith(with...))
	}
	if i.HasRequests != nil {
		p := apikey.HasRequests()
		if !*i.HasRequests {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIKeyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apikey.And(predicates...), nil
	}
}

// ChannelWhereInput represents a where input for filtering Channel queries.
type ChannelWhereInput struct {
	Predicates []predicate.Channel  `json:"-"`
	Not        *ChannelWhereInput   `json:"not,omitempty"`
	Or         []*ChannelWhereInput `json:"or,omitempty"`
	And        []*ChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "type" field predicates.
	Type      *channel.Type  `json:"type,omitempty"`
	TypeNEQ   *channel.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []channel.Type `json:"typeIn,omitempty"`
	TypeNotIn []channel.Type `json:"typeNotIn,omitempty"`

	// "base_url" field predicates.
	BaseURL             *string  `json:"baseURL,omitempty"`
	BaseURLNEQ          *string  `json:"baseURLNEQ,omitempty"`
	BaseURLIn           []string `json:"baseURLIn,omitempty"`
	BaseURLNotIn        []string `json:"baseURLNotIn,omitempty"`
	BaseURLGT           *string  `json:"baseURLGT,omitempty"`
	BaseURLGTE          *string  `json:"baseURLGTE,omitempty"`
	BaseURLLT           *string  `json:"baseURLLT,omitempty"`
	BaseURLLTE          *string  `json:"baseURLLTE,omitempty"`
	BaseURLContains     *string  `json:"baseURLContains,omitempty"`
	BaseURLHasPrefix    *string  `json:"baseURLHasPrefix,omitempty"`
	BaseURLHasSuffix    *string  `json:"baseURLHasSuffix,omitempty"`
	BaseURLEqualFold    *string  `json:"baseURLEqualFold,omitempty"`
	BaseURLContainsFold *string  `json:"baseURLContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "default_test_model" field predicates.
	DefaultTestModel             *string  `json:"defaultTestModel,omitempty"`
	DefaultTestModelNEQ          *string  `json:"defaultTestModelNEQ,omitempty"`
	DefaultTestModelIn           []string `json:"defaultTestModelIn,omitempty"`
	DefaultTestModelNotIn        []string `json:"defaultTestModelNotIn,omitempty"`
	DefaultTestModelGT           *string  `json:"defaultTestModelGT,omitempty"`
	DefaultTestModelGTE          *string  `json:"defaultTestModelGTE,omitempty"`
	DefaultTestModelLT           *string  `json:"defaultTestModelLT,omitempty"`
	DefaultTestModelLTE          *string  `json:"defaultTestModelLTE,omitempty"`
	DefaultTestModelContains     *string  `json:"defaultTestModelContains,omitempty"`
	DefaultTestModelHasPrefix    *string  `json:"defaultTestModelHasPrefix,omitempty"`
	DefaultTestModelHasSuffix    *string  `json:"defaultTestModelHasSuffix,omitempty"`
	DefaultTestModelEqualFold    *string  `json:"defaultTestModelEqualFold,omitempty"`
	DefaultTestModelContainsFold *string  `json:"defaultTestModelContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelWhereInput) AddPredicates(predicates ...predicate.Channel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelWhereInput filter on the ChannelQuery builder.
func (i *ChannelWhereInput) Filter(q *ChannelQuery) (*ChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelWhereInput is returned in case the ChannelWhereInput is empty.
var ErrEmptyChannelWhereInput = errors.New("ent: empty predicate ChannelWhereInput")

// P returns a predicate for filtering channels.
// An error is returned if the input is empty or invalid.
func (i *ChannelWhereInput) P() (predicate.Channel, error) {
	var predicates []predicate.Channel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Channel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Channel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channel.IDLTE(*i.IDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, channel.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, channel.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, channel.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, channel.TypeNotIn(i.TypeNotIn...))
	}
	if i.BaseURL != nil {
		predicates = append(predicates, channel.BaseURLEQ(*i.BaseURL))
	}
	if i.BaseURLNEQ != nil {
		predicates = append(predicates, channel.BaseURLNEQ(*i.BaseURLNEQ))
	}
	if len(i.BaseURLIn) > 0 {
		predicates = append(predicates, channel.BaseURLIn(i.BaseURLIn...))
	}
	if len(i.BaseURLNotIn) > 0 {
		predicates = append(predicates, channel.BaseURLNotIn(i.BaseURLNotIn...))
	}
	if i.BaseURLGT != nil {
		predicates = append(predicates, channel.BaseURLGT(*i.BaseURLGT))
	}
	if i.BaseURLGTE != nil {
		predicates = append(predicates, channel.BaseURLGTE(*i.BaseURLGTE))
	}
	if i.BaseURLLT != nil {
		predicates = append(predicates, channel.BaseURLLT(*i.BaseURLLT))
	}
	if i.BaseURLLTE != nil {
		predicates = append(predicates, channel.BaseURLLTE(*i.BaseURLLTE))
	}
	if i.BaseURLContains != nil {
		predicates = append(predicates, channel.BaseURLContains(*i.BaseURLContains))
	}
	if i.BaseURLHasPrefix != nil {
		predicates = append(predicates, channel.BaseURLHasPrefix(*i.BaseURLHasPrefix))
	}
	if i.BaseURLHasSuffix != nil {
		predicates = append(predicates, channel.BaseURLHasSuffix(*i.BaseURLHasSuffix))
	}
	if i.BaseURLEqualFold != nil {
		predicates = append(predicates, channel.BaseURLEqualFold(*i.BaseURLEqualFold))
	}
	if i.BaseURLContainsFold != nil {
		predicates = append(predicates, channel.BaseURLContainsFold(*i.BaseURLContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, channel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, channel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, channel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, channel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, channel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, channel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, channel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, channel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, channel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, channel.NameContainsFold(*i.NameContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, channel.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, channel.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, channel.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, channel.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, channel.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, channel.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, channel.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, channel.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, channel.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, channel.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, channel.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, channel.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, channel.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.DefaultTestModel != nil {
		predicates = append(predicates, channel.DefaultTestModelEQ(*i.DefaultTestModel))
	}
	if i.DefaultTestModelNEQ != nil {
		predicates = append(predicates, channel.DefaultTestModelNEQ(*i.DefaultTestModelNEQ))
	}
	if len(i.DefaultTestModelIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelIn(i.DefaultTestModelIn...))
	}
	if len(i.DefaultTestModelNotIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelNotIn(i.DefaultTestModelNotIn...))
	}
	if i.DefaultTestModelGT != nil {
		predicates = append(predicates, channel.DefaultTestModelGT(*i.DefaultTestModelGT))
	}
	if i.DefaultTestModelGTE != nil {
		predicates = append(predicates, channel.DefaultTestModelGTE(*i.DefaultTestModelGTE))
	}
	if i.DefaultTestModelLT != nil {
		predicates = append(predicates, channel.DefaultTestModelLT(*i.DefaultTestModelLT))
	}
	if i.DefaultTestModelLTE != nil {
		predicates = append(predicates, channel.DefaultTestModelLTE(*i.DefaultTestModelLTE))
	}
	if i.DefaultTestModelContains != nil {
		predicates = append(predicates, channel.DefaultTestModelContains(*i.DefaultTestModelContains))
	}
	if i.DefaultTestModelHasPrefix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasPrefix(*i.DefaultTestModelHasPrefix))
	}
	if i.DefaultTestModelHasSuffix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasSuffix(*i.DefaultTestModelHasSuffix))
	}
	if i.DefaultTestModelEqualFold != nil {
		predicates = append(predicates, channel.DefaultTestModelEqualFold(*i.DefaultTestModelEqualFold))
	}
	if i.DefaultTestModelContainsFold != nil {
		predicates = append(predicates, channel.DefaultTestModelContainsFold(*i.DefaultTestModelContainsFold))
	}

	if i.HasRequests != nil {
		p := channel.HasRequests()
		if !*i.HasRequests {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channel.And(predicates...), nil
	}
}

// JobWhereInput represents a where input for filtering Job queries.
type JobWhereInput struct {
	Predicates []predicate.Job  `json:"-"`
	Not        *JobWhereInput   `json:"not,omitempty"`
	Or         []*JobWhereInput `json:"or,omitempty"`
	And        []*JobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner_id" field predicates.
	OwnerID      *int  `json:"ownerID,omitempty"`
	OwnerIDNEQ   *int  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn    []int `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn []int `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT    *int  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE   *int  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT    *int  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE   *int  `json:"ownerIDLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "context" field predicates.
	Context             *string  `json:"context,omitempty"`
	ContextNEQ          *string  `json:"contextNEQ,omitempty"`
	ContextIn           []string `json:"contextIn,omitempty"`
	ContextNotIn        []string `json:"contextNotIn,omitempty"`
	ContextGT           *string  `json:"contextGT,omitempty"`
	ContextGTE          *string  `json:"contextGTE,omitempty"`
	ContextLT           *string  `json:"contextLT,omitempty"`
	ContextLTE          *string  `json:"contextLTE,omitempty"`
	ContextContains     *string  `json:"contextContains,omitempty"`
	ContextHasPrefix    *string  `json:"contextHasPrefix,omitempty"`
	ContextHasSuffix    *string  `json:"contextHasSuffix,omitempty"`
	ContextEqualFold    *string  `json:"contextEqualFold,omitempty"`
	ContextContainsFold *string  `json:"contextContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobWhereInput) AddPredicates(predicates ...predicate.Job) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobWhereInput filter on the JobQuery builder.
func (i *JobWhereInput) Filter(q *JobQuery) (*JobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobWhereInput is returned in case the JobWhereInput is empty.
var ErrEmptyJobWhereInput = errors.New("ent: empty predicate JobWhereInput")

// P returns a predicate for filtering jobs.
// An error is returned if the input is empty or invalid.
func (i *JobWhereInput) P() (predicate.Job, error) {
	var predicates []predicate.Job
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, job.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Job, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, job.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Job, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, job.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, job.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, job.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, job.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, job.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, job.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, job.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, job.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, job.IDLTE(*i.IDLTE))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, job.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, job.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, job.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, job.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, job.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, job.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, job.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, job.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, job.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, job.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, job.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, job.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, job.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, job.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, job.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, job.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, job.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, job.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, job.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, job.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, job.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Context != nil {
		predicates = append(predicates, job.ContextEQ(*i.Context))
	}
	if i.ContextNEQ != nil {
		predicates = append(predicates, job.ContextNEQ(*i.ContextNEQ))
	}
	if len(i.ContextIn) > 0 {
		predicates = append(predicates, job.ContextIn(i.ContextIn...))
	}
	if len(i.ContextNotIn) > 0 {
		predicates = append(predicates, job.ContextNotIn(i.ContextNotIn...))
	}
	if i.ContextGT != nil {
		predicates = append(predicates, job.ContextGT(*i.ContextGT))
	}
	if i.ContextGTE != nil {
		predicates = append(predicates, job.ContextGTE(*i.ContextGTE))
	}
	if i.ContextLT != nil {
		predicates = append(predicates, job.ContextLT(*i.ContextLT))
	}
	if i.ContextLTE != nil {
		predicates = append(predicates, job.ContextLTE(*i.ContextLTE))
	}
	if i.ContextContains != nil {
		predicates = append(predicates, job.ContextContains(*i.ContextContains))
	}
	if i.ContextHasPrefix != nil {
		predicates = append(predicates, job.ContextHasPrefix(*i.ContextHasPrefix))
	}
	if i.ContextHasSuffix != nil {
		predicates = append(predicates, job.ContextHasSuffix(*i.ContextHasSuffix))
	}
	if i.ContextEqualFold != nil {
		predicates = append(predicates, job.ContextEqualFold(*i.ContextEqualFold))
	}
	if i.ContextContainsFold != nil {
		predicates = append(predicates, job.ContextContainsFold(*i.ContextContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return job.And(predicates...), nil
	}
}

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "api_key_id" field predicates.
	APIKeyID      *int  `json:"apiKeyID,omitempty"`
	APIKeyIDNEQ   *int  `json:"apiKeyIDNEQ,omitempty"`
	APIKeyIDIn    []int `json:"apiKeyIDIn,omitempty"`
	APIKeyIDNotIn []int `json:"apiKeyIDNotIn,omitempty"`

	// "request_body" field predicates.
	RequestBody             *string  `json:"requestBody,omitempty"`
	RequestBodyNEQ          *string  `json:"requestBodyNEQ,omitempty"`
	RequestBodyIn           []string `json:"requestBodyIn,omitempty"`
	RequestBodyNotIn        []string `json:"requestBodyNotIn,omitempty"`
	RequestBodyGT           *string  `json:"requestBodyGT,omitempty"`
	RequestBodyGTE          *string  `json:"requestBodyGTE,omitempty"`
	RequestBodyLT           *string  `json:"requestBodyLT,omitempty"`
	RequestBodyLTE          *string  `json:"requestBodyLTE,omitempty"`
	RequestBodyContains     *string  `json:"requestBodyContains,omitempty"`
	RequestBodyHasPrefix    *string  `json:"requestBodyHasPrefix,omitempty"`
	RequestBodyHasSuffix    *string  `json:"requestBodyHasSuffix,omitempty"`
	RequestBodyEqualFold    *string  `json:"requestBodyEqualFold,omitempty"`
	RequestBodyContainsFold *string  `json:"requestBodyContainsFold,omitempty"`

	// "response_body" field predicates.
	ResponseBody             *string  `json:"responseBody,omitempty"`
	ResponseBodyNEQ          *string  `json:"responseBodyNEQ,omitempty"`
	ResponseBodyIn           []string `json:"responseBodyIn,omitempty"`
	ResponseBodyNotIn        []string `json:"responseBodyNotIn,omitempty"`
	ResponseBodyGT           *string  `json:"responseBodyGT,omitempty"`
	ResponseBodyGTE          *string  `json:"responseBodyGTE,omitempty"`
	ResponseBodyLT           *string  `json:"responseBodyLT,omitempty"`
	ResponseBodyLTE          *string  `json:"responseBodyLTE,omitempty"`
	ResponseBodyContains     *string  `json:"responseBodyContains,omitempty"`
	ResponseBodyHasPrefix    *string  `json:"responseBodyHasPrefix,omitempty"`
	ResponseBodyHasSuffix    *string  `json:"responseBodyHasSuffix,omitempty"`
	ResponseBodyIsNil        bool     `json:"responseBodyIsNil,omitempty"`
	ResponseBodyNotNil       bool     `json:"responseBodyNotNil,omitempty"`
	ResponseBodyEqualFold    *string  `json:"responseBodyEqualFold,omitempty"`
	ResponseBodyContainsFold *string  `json:"responseBodyContainsFold,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "api_key" edge predicates.
	HasAPIKey     *bool               `json:"hasAPIKey,omitempty"`
	HasAPIKeyWith []*APIKeyWhereInput `json:"hasAPIKeyWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, request.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, request.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, request.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, request.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.APIKeyID != nil {
		predicates = append(predicates, request.APIKeyIDEQ(*i.APIKeyID))
	}
	if i.APIKeyIDNEQ != nil {
		predicates = append(predicates, request.APIKeyIDNEQ(*i.APIKeyIDNEQ))
	}
	if len(i.APIKeyIDIn) > 0 {
		predicates = append(predicates, request.APIKeyIDIn(i.APIKeyIDIn...))
	}
	if len(i.APIKeyIDNotIn) > 0 {
		predicates = append(predicates, request.APIKeyIDNotIn(i.APIKeyIDNotIn...))
	}
	if i.RequestBody != nil {
		predicates = append(predicates, request.RequestBodyEQ(*i.RequestBody))
	}
	if i.RequestBodyNEQ != nil {
		predicates = append(predicates, request.RequestBodyNEQ(*i.RequestBodyNEQ))
	}
	if len(i.RequestBodyIn) > 0 {
		predicates = append(predicates, request.RequestBodyIn(i.RequestBodyIn...))
	}
	if len(i.RequestBodyNotIn) > 0 {
		predicates = append(predicates, request.RequestBodyNotIn(i.RequestBodyNotIn...))
	}
	if i.RequestBodyGT != nil {
		predicates = append(predicates, request.RequestBodyGT(*i.RequestBodyGT))
	}
	if i.RequestBodyGTE != nil {
		predicates = append(predicates, request.RequestBodyGTE(*i.RequestBodyGTE))
	}
	if i.RequestBodyLT != nil {
		predicates = append(predicates, request.RequestBodyLT(*i.RequestBodyLT))
	}
	if i.RequestBodyLTE != nil {
		predicates = append(predicates, request.RequestBodyLTE(*i.RequestBodyLTE))
	}
	if i.RequestBodyContains != nil {
		predicates = append(predicates, request.RequestBodyContains(*i.RequestBodyContains))
	}
	if i.RequestBodyHasPrefix != nil {
		predicates = append(predicates, request.RequestBodyHasPrefix(*i.RequestBodyHasPrefix))
	}
	if i.RequestBodyHasSuffix != nil {
		predicates = append(predicates, request.RequestBodyHasSuffix(*i.RequestBodyHasSuffix))
	}
	if i.RequestBodyEqualFold != nil {
		predicates = append(predicates, request.RequestBodyEqualFold(*i.RequestBodyEqualFold))
	}
	if i.RequestBodyContainsFold != nil {
		predicates = append(predicates, request.RequestBodyContainsFold(*i.RequestBodyContainsFold))
	}
	if i.ResponseBody != nil {
		predicates = append(predicates, request.ResponseBodyEQ(*i.ResponseBody))
	}
	if i.ResponseBodyNEQ != nil {
		predicates = append(predicates, request.ResponseBodyNEQ(*i.ResponseBodyNEQ))
	}
	if len(i.ResponseBodyIn) > 0 {
		predicates = append(predicates, request.ResponseBodyIn(i.ResponseBodyIn...))
	}
	if len(i.ResponseBodyNotIn) > 0 {
		predicates = append(predicates, request.ResponseBodyNotIn(i.ResponseBodyNotIn...))
	}
	if i.ResponseBodyGT != nil {
		predicates = append(predicates, request.ResponseBodyGT(*i.ResponseBodyGT))
	}
	if i.ResponseBodyGTE != nil {
		predicates = append(predicates, request.ResponseBodyGTE(*i.ResponseBodyGTE))
	}
	if i.ResponseBodyLT != nil {
		predicates = append(predicates, request.ResponseBodyLT(*i.ResponseBodyLT))
	}
	if i.ResponseBodyLTE != nil {
		predicates = append(predicates, request.ResponseBodyLTE(*i.ResponseBodyLTE))
	}
	if i.ResponseBodyContains != nil {
		predicates = append(predicates, request.ResponseBodyContains(*i.ResponseBodyContains))
	}
	if i.ResponseBodyHasPrefix != nil {
		predicates = append(predicates, request.ResponseBodyHasPrefix(*i.ResponseBodyHasPrefix))
	}
	if i.ResponseBodyHasSuffix != nil {
		predicates = append(predicates, request.ResponseBodyHasSuffix(*i.ResponseBodyHasSuffix))
	}
	if i.ResponseBodyIsNil {
		predicates = append(predicates, request.ResponseBodyIsNil())
	}
	if i.ResponseBodyNotNil {
		predicates = append(predicates, request.ResponseBodyNotNil())
	}
	if i.ResponseBodyEqualFold != nil {
		predicates = append(predicates, request.ResponseBodyEqualFold(*i.ResponseBodyEqualFold))
	}
	if i.ResponseBodyContainsFold != nil {
		predicates = append(predicates, request.ResponseBodyContainsFold(*i.ResponseBodyContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUser != nil {
		p := request.HasUser()
		if !*i.HasUser {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasUserWith(with...))
	}
	if i.HasAPIKey != nil {
		p := request.HasAPIKey()
		if !*i.HasAPIKey {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeyWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeyWith))
		for _, w := range i.HasAPIKeyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasAPIKeyWith(with...))
	}
	if i.HasExecutions != nil {
		p := request.HasExecutions()
		if !*i.HasExecutions {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}

// RequestExecutionWhereInput represents a where input for filtering RequestExecution queries.
type RequestExecutionWhereInput struct {
	Predicates []predicate.RequestExecution  `json:"-"`
	Not        *RequestExecutionWhereInput   `json:"not,omitempty"`
	Or         []*RequestExecutionWhereInput `json:"or,omitempty"`
	And        []*RequestExecutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`
	UserIDGT    *int  `json:"userIDGT,omitempty"`
	UserIDGTE   *int  `json:"userIDGTE,omitempty"`
	UserIDLT    *int  `json:"userIDLT,omitempty"`
	UserIDLTE   *int  `json:"userIDLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`
	ChannelIDGT    *int  `json:"channelIDGT,omitempty"`
	ChannelIDGTE   *int  `json:"channelIDGTE,omitempty"`
	ChannelIDLT    *int  `json:"channelIDLT,omitempty"`
	ChannelIDLTE   *int  `json:"channelIDLTE,omitempty"`

	// "model_id" field predicates.
	ModelID      *int  `json:"modelID,omitempty"`
	ModelIDNEQ   *int  `json:"modelIDNEQ,omitempty"`
	ModelIDIn    []int `json:"modelIDIn,omitempty"`
	ModelIDNotIn []int `json:"modelIDNotIn,omitempty"`
	ModelIDGT    *int  `json:"modelIDGT,omitempty"`
	ModelIDGTE   *int  `json:"modelIDGTE,omitempty"`
	ModelIDLT    *int  `json:"modelIDLT,omitempty"`
	ModelIDLTE   *int  `json:"modelIDLTE,omitempty"`

	// "request_body" field predicates.
	RequestBody             *string  `json:"requestBody,omitempty"`
	RequestBodyNEQ          *string  `json:"requestBodyNEQ,omitempty"`
	RequestBodyIn           []string `json:"requestBodyIn,omitempty"`
	RequestBodyNotIn        []string `json:"requestBodyNotIn,omitempty"`
	RequestBodyGT           *string  `json:"requestBodyGT,omitempty"`
	RequestBodyGTE          *string  `json:"requestBodyGTE,omitempty"`
	RequestBodyLT           *string  `json:"requestBodyLT,omitempty"`
	RequestBodyLTE          *string  `json:"requestBodyLTE,omitempty"`
	RequestBodyContains     *string  `json:"requestBodyContains,omitempty"`
	RequestBodyHasPrefix    *string  `json:"requestBodyHasPrefix,omitempty"`
	RequestBodyHasSuffix    *string  `json:"requestBodyHasSuffix,omitempty"`
	RequestBodyEqualFold    *string  `json:"requestBodyEqualFold,omitempty"`
	RequestBodyContainsFold *string  `json:"requestBodyContainsFold,omitempty"`

	// "response_body" field predicates.
	ResponseBody             *string  `json:"responseBody,omitempty"`
	ResponseBodyNEQ          *string  `json:"responseBodyNEQ,omitempty"`
	ResponseBodyIn           []string `json:"responseBodyIn,omitempty"`
	ResponseBodyNotIn        []string `json:"responseBodyNotIn,omitempty"`
	ResponseBodyGT           *string  `json:"responseBodyGT,omitempty"`
	ResponseBodyGTE          *string  `json:"responseBodyGTE,omitempty"`
	ResponseBodyLT           *string  `json:"responseBodyLT,omitempty"`
	ResponseBodyLTE          *string  `json:"responseBodyLTE,omitempty"`
	ResponseBodyContains     *string  `json:"responseBodyContains,omitempty"`
	ResponseBodyHasPrefix    *string  `json:"responseBodyHasPrefix,omitempty"`
	ResponseBodyHasSuffix    *string  `json:"responseBodyHasSuffix,omitempty"`
	ResponseBodyIsNil        bool     `json:"responseBodyIsNil,omitempty"`
	ResponseBodyNotNil       bool     `json:"responseBodyNotNil,omitempty"`
	ResponseBodyEqualFold    *string  `json:"responseBodyEqualFold,omitempty"`
	ResponseBodyContainsFold *string  `json:"responseBodyContainsFold,omitempty"`

	// "status" field predicates.
	Status      *requestexecution.Status  `json:"status,omitempty"`
	StatusNEQ   *requestexecution.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []requestexecution.Status `json:"statusIn,omitempty"`
	StatusNotIn []requestexecution.Status `json:"statusNotIn,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestExecutionWhereInput) AddPredicates(predicates ...predicate.RequestExecution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestExecutionWhereInput filter on the RequestExecutionQuery builder.
func (i *RequestExecutionWhereInput) Filter(q *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestExecutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestExecutionWhereInput is returned in case the RequestExecutionWhereInput is empty.
var ErrEmptyRequestExecutionWhereInput = errors.New("ent: empty predicate RequestExecutionWhereInput")

// P returns a predicate for filtering requestexecutions.
// An error is returned if the input is empty or invalid.
func (i *RequestExecutionWhereInput) P() (predicate.RequestExecution, error) {
	var predicates []predicate.RequestExecution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, requestexecution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, requestexecution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, requestexecution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, requestexecution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, requestexecution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, requestexecution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, requestexecution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, requestexecution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, requestexecution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, requestexecution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, requestexecution.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, requestexecution.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, requestexecution.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, requestexecution.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, requestexecution.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, requestexecution.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, requestexecution.UserIDLTE(*i.UserIDLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, requestexecution.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, requestexecution.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, requestexecution.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ChannelIDGT != nil {
		predicates = append(predicates, requestexecution.ChannelIDGT(*i.ChannelIDGT))
	}
	if i.ChannelIDGTE != nil {
		predicates = append(predicates, requestexecution.ChannelIDGTE(*i.ChannelIDGTE))
	}
	if i.ChannelIDLT != nil {
		predicates = append(predicates, requestexecution.ChannelIDLT(*i.ChannelIDLT))
	}
	if i.ChannelIDLTE != nil {
		predicates = append(predicates, requestexecution.ChannelIDLTE(*i.ChannelIDLTE))
	}
	if i.ModelID != nil {
		predicates = append(predicates, requestexecution.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, requestexecution.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, requestexecution.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, requestexecution.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, requestexecution.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.RequestBody != nil {
		predicates = append(predicates, requestexecution.RequestBodyEQ(*i.RequestBody))
	}
	if i.RequestBodyNEQ != nil {
		predicates = append(predicates, requestexecution.RequestBodyNEQ(*i.RequestBodyNEQ))
	}
	if len(i.RequestBodyIn) > 0 {
		predicates = append(predicates, requestexecution.RequestBodyIn(i.RequestBodyIn...))
	}
	if len(i.RequestBodyNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestBodyNotIn(i.RequestBodyNotIn...))
	}
	if i.RequestBodyGT != nil {
		predicates = append(predicates, requestexecution.RequestBodyGT(*i.RequestBodyGT))
	}
	if i.RequestBodyGTE != nil {
		predicates = append(predicates, requestexecution.RequestBodyGTE(*i.RequestBodyGTE))
	}
	if i.RequestBodyLT != nil {
		predicates = append(predicates, requestexecution.RequestBodyLT(*i.RequestBodyLT))
	}
	if i.RequestBodyLTE != nil {
		predicates = append(predicates, requestexecution.RequestBodyLTE(*i.RequestBodyLTE))
	}
	if i.RequestBodyContains != nil {
		predicates = append(predicates, requestexecution.RequestBodyContains(*i.RequestBodyContains))
	}
	if i.RequestBodyHasPrefix != nil {
		predicates = append(predicates, requestexecution.RequestBodyHasPrefix(*i.RequestBodyHasPrefix))
	}
	if i.RequestBodyHasSuffix != nil {
		predicates = append(predicates, requestexecution.RequestBodyHasSuffix(*i.RequestBodyHasSuffix))
	}
	if i.RequestBodyEqualFold != nil {
		predicates = append(predicates, requestexecution.RequestBodyEqualFold(*i.RequestBodyEqualFold))
	}
	if i.RequestBodyContainsFold != nil {
		predicates = append(predicates, requestexecution.RequestBodyContainsFold(*i.RequestBodyContainsFold))
	}
	if i.ResponseBody != nil {
		predicates = append(predicates, requestexecution.ResponseBodyEQ(*i.ResponseBody))
	}
	if i.ResponseBodyNEQ != nil {
		predicates = append(predicates, requestexecution.ResponseBodyNEQ(*i.ResponseBodyNEQ))
	}
	if len(i.ResponseBodyIn) > 0 {
		predicates = append(predicates, requestexecution.ResponseBodyIn(i.ResponseBodyIn...))
	}
	if len(i.ResponseBodyNotIn) > 0 {
		predicates = append(predicates, requestexecution.ResponseBodyNotIn(i.ResponseBodyNotIn...))
	}
	if i.ResponseBodyGT != nil {
		predicates = append(predicates, requestexecution.ResponseBodyGT(*i.ResponseBodyGT))
	}
	if i.ResponseBodyGTE != nil {
		predicates = append(predicates, requestexecution.ResponseBodyGTE(*i.ResponseBodyGTE))
	}
	if i.ResponseBodyLT != nil {
		predicates = append(predicates, requestexecution.ResponseBodyLT(*i.ResponseBodyLT))
	}
	if i.ResponseBodyLTE != nil {
		predicates = append(predicates, requestexecution.ResponseBodyLTE(*i.ResponseBodyLTE))
	}
	if i.ResponseBodyContains != nil {
		predicates = append(predicates, requestexecution.ResponseBodyContains(*i.ResponseBodyContains))
	}
	if i.ResponseBodyHasPrefix != nil {
		predicates = append(predicates, requestexecution.ResponseBodyHasPrefix(*i.ResponseBodyHasPrefix))
	}
	if i.ResponseBodyHasSuffix != nil {
		predicates = append(predicates, requestexecution.ResponseBodyHasSuffix(*i.ResponseBodyHasSuffix))
	}
	if i.ResponseBodyIsNil {
		predicates = append(predicates, requestexecution.ResponseBodyIsNil())
	}
	if i.ResponseBodyNotNil {
		predicates = append(predicates, requestexecution.ResponseBodyNotNil())
	}
	if i.ResponseBodyEqualFold != nil {
		predicates = append(predicates, requestexecution.ResponseBodyEqualFold(*i.ResponseBodyEqualFold))
	}
	if i.ResponseBodyContainsFold != nil {
		predicates = append(predicates, requestexecution.ResponseBodyContainsFold(*i.ResponseBodyContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, requestexecution.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, requestexecution.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, requestexecution.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, requestexecution.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasRequest != nil {
		p := requestexecution.HasRequest()
		if !*i.HasRequest {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasRequestWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestExecutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return requestexecution.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasRequests != nil {
		p := user.HasRequests()
		if !*i.HasRequests {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRequestsWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := user.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPIKeysWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
