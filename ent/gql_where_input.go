// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"

	"github.com/looplj/axonhub/ent/apikey"
	"github.com/looplj/axonhub/ent/job"
	"github.com/looplj/axonhub/ent/predicate"
	"github.com/looplj/axonhub/ent/request"
	"github.com/looplj/axonhub/ent/requestexecution"
	"github.com/looplj/axonhub/ent/user"
)

// APIKeyWhereInput represents a where input for filtering APIKey queries.
type APIKeyWhereInput struct {
	Predicates []predicate.APIKey  `json:"-"`
	Not        *APIKeyWhereInput   `json:"not,omitempty"`
	Or         []*APIKeyWhereInput `json:"or,omitempty"`
	And        []*APIKeyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "key" field predicates.
	Key      *int  `json:"key,omitempty"`
	KeyNEQ   *int  `json:"keyNEQ,omitempty"`
	KeyIn    []int `json:"keyIn,omitempty"`
	KeyNotIn []int `json:"keyNotIn,omitempty"`
	KeyGT    *int  `json:"keyGT,omitempty"`
	KeyGTE   *int  `json:"keyGTE,omitempty"`
	KeyLT    *int  `json:"keyLT,omitempty"`
	KeyLTE   *int  `json:"keyLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIKeyWhereInput) AddPredicates(predicates ...predicate.APIKey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIKeyWhereInput filter on the APIKeyQuery builder.
func (i *APIKeyWhereInput) Filter(q *APIKeyQuery) (*APIKeyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIKeyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIKeyWhereInput is returned in case the APIKeyWhereInput is empty.
var ErrEmptyAPIKeyWhereInput = errors.New("ent: empty predicate APIKeyWhereInput")

// P returns a predicate for filtering apikeys.
// An error is returned if the input is empty or invalid.
func (i *APIKeyWhereInput) P() (predicate.APIKey, error) {
	var predicates []predicate.APIKey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apikey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIKey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apikey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIKey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apikey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apikey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apikey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apikey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apikey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apikey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apikey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apikey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apikey.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, apikey.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, apikey.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, apikey.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, apikey.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.Key != nil {
		predicates = append(predicates, apikey.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apikey.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apikey.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apikey.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apikey.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apikey.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apikey.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apikey.KeyLTE(*i.KeyLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, apikey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apikey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apikey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apikey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apikey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apikey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apikey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apikey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apikey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apikey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apikey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apikey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apikey.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasUser != nil {
		p := apikey.HasUser()
		if !*i.HasUser {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasUserWith(with...))
	}
	if i.HasRequests != nil {
		p := apikey.HasRequests()
		if !*i.HasRequests {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIKeyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apikey.And(predicates...), nil
	}
}

// JobWhereInput represents a where input for filtering Job queries.
type JobWhereInput struct {
	Predicates []predicate.Job  `json:"-"`
	Not        *JobWhereInput   `json:"not,omitempty"`
	Or         []*JobWhereInput `json:"or,omitempty"`
	And        []*JobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner_id" field predicates.
	OwnerID      *int  `json:"ownerID,omitempty"`
	OwnerIDNEQ   *int  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn    []int `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn []int `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT    *int  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE   *int  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT    *int  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE   *int  `json:"ownerIDLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "context" field predicates.
	Context             *string  `json:"context,omitempty"`
	ContextNEQ          *string  `json:"contextNEQ,omitempty"`
	ContextIn           []string `json:"contextIn,omitempty"`
	ContextNotIn        []string `json:"contextNotIn,omitempty"`
	ContextGT           *string  `json:"contextGT,omitempty"`
	ContextGTE          *string  `json:"contextGTE,omitempty"`
	ContextLT           *string  `json:"contextLT,omitempty"`
	ContextLTE          *string  `json:"contextLTE,omitempty"`
	ContextContains     *string  `json:"contextContains,omitempty"`
	ContextHasPrefix    *string  `json:"contextHasPrefix,omitempty"`
	ContextHasSuffix    *string  `json:"contextHasSuffix,omitempty"`
	ContextEqualFold    *string  `json:"contextEqualFold,omitempty"`
	ContextContainsFold *string  `json:"contextContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobWhereInput) AddPredicates(predicates ...predicate.Job) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobWhereInput filter on the JobQuery builder.
func (i *JobWhereInput) Filter(q *JobQuery) (*JobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobWhereInput is returned in case the JobWhereInput is empty.
var ErrEmptyJobWhereInput = errors.New("ent: empty predicate JobWhereInput")

// P returns a predicate for filtering jobs.
// An error is returned if the input is empty or invalid.
func (i *JobWhereInput) P() (predicate.Job, error) {
	var predicates []predicate.Job
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, job.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Job, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, job.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Job, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, job.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, job.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, job.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, job.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, job.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, job.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, job.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, job.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, job.IDLTE(*i.IDLTE))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, job.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, job.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, job.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, job.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, job.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, job.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, job.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, job.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, job.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, job.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, job.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, job.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, job.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, job.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, job.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, job.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, job.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, job.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, job.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, job.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, job.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Context != nil {
		predicates = append(predicates, job.ContextEQ(*i.Context))
	}
	if i.ContextNEQ != nil {
		predicates = append(predicates, job.ContextNEQ(*i.ContextNEQ))
	}
	if len(i.ContextIn) > 0 {
		predicates = append(predicates, job.ContextIn(i.ContextIn...))
	}
	if len(i.ContextNotIn) > 0 {
		predicates = append(predicates, job.ContextNotIn(i.ContextNotIn...))
	}
	if i.ContextGT != nil {
		predicates = append(predicates, job.ContextGT(*i.ContextGT))
	}
	if i.ContextGTE != nil {
		predicates = append(predicates, job.ContextGTE(*i.ContextGTE))
	}
	if i.ContextLT != nil {
		predicates = append(predicates, job.ContextLT(*i.ContextLT))
	}
	if i.ContextLTE != nil {
		predicates = append(predicates, job.ContextLTE(*i.ContextLTE))
	}
	if i.ContextContains != nil {
		predicates = append(predicates, job.ContextContains(*i.ContextContains))
	}
	if i.ContextHasPrefix != nil {
		predicates = append(predicates, job.ContextHasPrefix(*i.ContextHasPrefix))
	}
	if i.ContextHasSuffix != nil {
		predicates = append(predicates, job.ContextHasSuffix(*i.ContextHasSuffix))
	}
	if i.ContextEqualFold != nil {
		predicates = append(predicates, job.ContextEqualFold(*i.ContextEqualFold))
	}
	if i.ContextContainsFold != nil {
		predicates = append(predicates, job.ContextContainsFold(*i.ContextContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return job.And(predicates...), nil
	}
}

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "request_body" field predicates.
	RequestBody             *string  `json:"requestBody,omitempty"`
	RequestBodyNEQ          *string  `json:"requestBodyNEQ,omitempty"`
	RequestBodyIn           []string `json:"requestBodyIn,omitempty"`
	RequestBodyNotIn        []string `json:"requestBodyNotIn,omitempty"`
	RequestBodyGT           *string  `json:"requestBodyGT,omitempty"`
	RequestBodyGTE          *string  `json:"requestBodyGTE,omitempty"`
	RequestBodyLT           *string  `json:"requestBodyLT,omitempty"`
	RequestBodyLTE          *string  `json:"requestBodyLTE,omitempty"`
	RequestBodyContains     *string  `json:"requestBodyContains,omitempty"`
	RequestBodyHasPrefix    *string  `json:"requestBodyHasPrefix,omitempty"`
	RequestBodyHasSuffix    *string  `json:"requestBodyHasSuffix,omitempty"`
	RequestBodyEqualFold    *string  `json:"requestBodyEqualFold,omitempty"`
	RequestBodyContainsFold *string  `json:"requestBodyContainsFold,omitempty"`

	// "response_body" field predicates.
	ResponseBody             *string  `json:"responseBody,omitempty"`
	ResponseBodyNEQ          *string  `json:"responseBodyNEQ,omitempty"`
	ResponseBodyIn           []string `json:"responseBodyIn,omitempty"`
	ResponseBodyNotIn        []string `json:"responseBodyNotIn,omitempty"`
	ResponseBodyGT           *string  `json:"responseBodyGT,omitempty"`
	ResponseBodyGTE          *string  `json:"responseBodyGTE,omitempty"`
	ResponseBodyLT           *string  `json:"responseBodyLT,omitempty"`
	ResponseBodyLTE          *string  `json:"responseBodyLTE,omitempty"`
	ResponseBodyContains     *string  `json:"responseBodyContains,omitempty"`
	ResponseBodyHasPrefix    *string  `json:"responseBodyHasPrefix,omitempty"`
	ResponseBodyHasSuffix    *string  `json:"responseBodyHasSuffix,omitempty"`
	ResponseBodyEqualFold    *string  `json:"responseBodyEqualFold,omitempty"`
	ResponseBodyContainsFold *string  `json:"responseBodyContainsFold,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int64  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int64  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int64 `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int64 `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int64  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int64  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int64  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int64  `json:"deletedAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "api_key" edge predicates.
	HasAPIKey     *bool               `json:"hasAPIKey,omitempty"`
	HasAPIKeyWith []*APIKeyWhereInput `json:"hasAPIKeyWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, request.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, request.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, request.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, request.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, request.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, request.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, request.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, request.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, request.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, request.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, request.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, request.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, request.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.RequestBody != nil {
		predicates = append(predicates, request.RequestBodyEQ(*i.RequestBody))
	}
	if i.RequestBodyNEQ != nil {
		predicates = append(predicates, request.RequestBodyNEQ(*i.RequestBodyNEQ))
	}
	if len(i.RequestBodyIn) > 0 {
		predicates = append(predicates, request.RequestBodyIn(i.RequestBodyIn...))
	}
	if len(i.RequestBodyNotIn) > 0 {
		predicates = append(predicates, request.RequestBodyNotIn(i.RequestBodyNotIn...))
	}
	if i.RequestBodyGT != nil {
		predicates = append(predicates, request.RequestBodyGT(*i.RequestBodyGT))
	}
	if i.RequestBodyGTE != nil {
		predicates = append(predicates, request.RequestBodyGTE(*i.RequestBodyGTE))
	}
	if i.RequestBodyLT != nil {
		predicates = append(predicates, request.RequestBodyLT(*i.RequestBodyLT))
	}
	if i.RequestBodyLTE != nil {
		predicates = append(predicates, request.RequestBodyLTE(*i.RequestBodyLTE))
	}
	if i.RequestBodyContains != nil {
		predicates = append(predicates, request.RequestBodyContains(*i.RequestBodyContains))
	}
	if i.RequestBodyHasPrefix != nil {
		predicates = append(predicates, request.RequestBodyHasPrefix(*i.RequestBodyHasPrefix))
	}
	if i.RequestBodyHasSuffix != nil {
		predicates = append(predicates, request.RequestBodyHasSuffix(*i.RequestBodyHasSuffix))
	}
	if i.RequestBodyEqualFold != nil {
		predicates = append(predicates, request.RequestBodyEqualFold(*i.RequestBodyEqualFold))
	}
	if i.RequestBodyContainsFold != nil {
		predicates = append(predicates, request.RequestBodyContainsFold(*i.RequestBodyContainsFold))
	}
	if i.ResponseBody != nil {
		predicates = append(predicates, request.ResponseBodyEQ(*i.ResponseBody))
	}
	if i.ResponseBodyNEQ != nil {
		predicates = append(predicates, request.ResponseBodyNEQ(*i.ResponseBodyNEQ))
	}
	if len(i.ResponseBodyIn) > 0 {
		predicates = append(predicates, request.ResponseBodyIn(i.ResponseBodyIn...))
	}
	if len(i.ResponseBodyNotIn) > 0 {
		predicates = append(predicates, request.ResponseBodyNotIn(i.ResponseBodyNotIn...))
	}
	if i.ResponseBodyGT != nil {
		predicates = append(predicates, request.ResponseBodyGT(*i.ResponseBodyGT))
	}
	if i.ResponseBodyGTE != nil {
		predicates = append(predicates, request.ResponseBodyGTE(*i.ResponseBodyGTE))
	}
	if i.ResponseBodyLT != nil {
		predicates = append(predicates, request.ResponseBodyLT(*i.ResponseBodyLT))
	}
	if i.ResponseBodyLTE != nil {
		predicates = append(predicates, request.ResponseBodyLTE(*i.ResponseBodyLTE))
	}
	if i.ResponseBodyContains != nil {
		predicates = append(predicates, request.ResponseBodyContains(*i.ResponseBodyContains))
	}
	if i.ResponseBodyHasPrefix != nil {
		predicates = append(predicates, request.ResponseBodyHasPrefix(*i.ResponseBodyHasPrefix))
	}
	if i.ResponseBodyHasSuffix != nil {
		predicates = append(predicates, request.ResponseBodyHasSuffix(*i.ResponseBodyHasSuffix))
	}
	if i.ResponseBodyEqualFold != nil {
		predicates = append(predicates, request.ResponseBodyEqualFold(*i.ResponseBodyEqualFold))
	}
	if i.ResponseBodyContainsFold != nil {
		predicates = append(predicates, request.ResponseBodyContainsFold(*i.ResponseBodyContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, request.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, request.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, request.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, request.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, request.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, request.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, request.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, request.DeletedAtLTE(*i.DeletedAtLTE))
	}

	if i.HasUser != nil {
		p := request.HasUser()
		if !*i.HasUser {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasUserWith(with...))
	}
	if i.HasAPIKey != nil {
		p := request.HasAPIKey()
		if !*i.HasAPIKey {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeyWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeyWith))
		for _, w := range i.HasAPIKeyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasAPIKeyWith(with...))
	}
	if i.HasExecutions != nil {
		p := request.HasExecutions()
		if !*i.HasExecutions {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}

// RequestExecutionWhereInput represents a where input for filtering RequestExecution queries.
type RequestExecutionWhereInput struct {
	Predicates []predicate.RequestExecution  `json:"-"`
	Not        *RequestExecutionWhereInput   `json:"not,omitempty"`
	Or         []*RequestExecutionWhereInput `json:"or,omitempty"`
	And        []*RequestExecutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`
	UserIDGT    *int  `json:"userIDGT,omitempty"`
	UserIDGTE   *int  `json:"userIDGTE,omitempty"`
	UserIDLT    *int  `json:"userIDLT,omitempty"`
	UserIDLTE   *int  `json:"userIDLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestExecutionWhereInput) AddPredicates(predicates ...predicate.RequestExecution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestExecutionWhereInput filter on the RequestExecutionQuery builder.
func (i *RequestExecutionWhereInput) Filter(q *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestExecutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestExecutionWhereInput is returned in case the RequestExecutionWhereInput is empty.
var ErrEmptyRequestExecutionWhereInput = errors.New("ent: empty predicate RequestExecutionWhereInput")

// P returns a predicate for filtering requestexecutions.
// An error is returned if the input is empty or invalid.
func (i *RequestExecutionWhereInput) P() (predicate.RequestExecution, error) {
	var predicates []predicate.RequestExecution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, requestexecution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, requestexecution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, requestexecution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, requestexecution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, requestexecution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, requestexecution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, requestexecution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, requestexecution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, requestexecution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, requestexecution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, requestexecution.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, requestexecution.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, requestexecution.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, requestexecution.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, requestexecution.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, requestexecution.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, requestexecution.UserIDLTE(*i.UserIDLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, requestexecution.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, requestexecution.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDNotIn(i.RequestIDNotIn...))
	}

	if i.HasRequest != nil {
		p := requestexecution.HasRequest()
		if !*i.HasRequest {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasRequestWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestExecutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return requestexecution.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`
	UserIDGT    *int  `json:"userIDGT,omitempty"`
	UserIDGTE   *int  `json:"userIDGTE,omitempty"`
	UserIDLT    *int  `json:"userIDLT,omitempty"`
	UserIDLTE   *int  `json:"userIDLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, user.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, user.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, user.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, user.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, user.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, user.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, user.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, user.UserIDLTE(*i.UserIDLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasRequests != nil {
		p := user.HasRequests()
		if !*i.HasRequests {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRequestsWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := user.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPIKeysWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
