package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76-dev

import (
	"context"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/samber/lo"
	"github.com/looplj/axonhub/internal/ent"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/log"
	"github.com/looplj/axonhub/internal/objects"
	"github.com/looplj/axonhub/internal/scopes"
)

// DashboardOverview is the resolver for the dashboardOverview field.
func (r *queryResolver) DashboardOverview(ctx context.Context) (*DashboardOverview, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	// Initialize response with defaults to handle partial failures gracefully
	stats := &DashboardOverview{
		TotalUsers:          0,
		TotalRequests:       0,
		RequestsToday:       0,
		RequestsThisWeek:    0,
		RequestsThisMonth:   0,
		FailedRequests:      0,
		AverageResponseTime: nil,
	}

	// Get total counts with defensive error handling
	if totalUsers, err := r.client.User.Query().Count(ctx); err != nil {
		log.Warn(ctx, "failed to count users", log.Cause(err))
	} else {
		stats.TotalUsers = totalUsers
	}

	if totalRequests, err := r.client.Request.Query().Count(ctx); err != nil {
		log.Warn(ctx, "failed to count requests", log.Cause(err))
	} else {
		stats.TotalRequests = totalRequests
	}

	now := time.Now()
	today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
	weekAgo := today.AddDate(0, 0, -7)
	monthAgo := today.AddDate(0, -1, 0)

	// Get time-based counts with optimized single queries
	if requestsToday, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(today)).
		Count(ctx); err != nil {
		log.Warn(ctx, "failed to count today's requests", log.Cause(err))
	} else {
		stats.RequestsToday = requestsToday
	}

	if requestsThisWeek, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(weekAgo)).
		Count(ctx); err != nil {
		log.Warn(ctx, "failed to count this week's requests", log.Cause(err))
	} else {
		stats.RequestsThisWeek = requestsThisWeek
	}

	if requestsThisMonth, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(monthAgo)).
		Count(ctx); err != nil {
		log.Warn(ctx, "failed to count this month's requests", log.Cause(err))
	} else {
		stats.RequestsThisMonth = requestsThisMonth
	}

	if failedRequests, err := r.client.Request.Query().
		Where(request.StatusEQ(request.StatusFailed)).
		Count(ctx); err != nil {
		log.Warn(ctx, "failed to count failed requests", log.Cause(err))
	} else {
		stats.FailedRequests = failedRequests
	}

	// TODO: Calculate average response time from request execution data
	// This would require additional database schema changes to store response times

	return stats, nil
}

// RequestStatsByChannel is the resolver for the requestStatsByChannel field.
func (r *queryResolver) RequestStatsByChannel(ctx context.Context) ([]*RequestStatsByChannel, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	// Use efficient aggregation query to avoid loading all data into memory
	type channelStats struct {
		ChannelID int `json:"channel_id"`
		Count     int `json:"request_count"`
	}

	var results []channelStats

	// Aggregate by channel_id directly in the database using requests table
	err := r.client.Request.Query().
		Where(request.ChannelIDNotNil()). // Only include requests with channel ID set
		GroupBy(request.FieldChannelID).
		Aggregate(ent.As(ent.Count(), "request_count")).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get requests by channel: %w", err)
	}

	if len(results) == 0 {
		return []*RequestStatsByChannel{}, nil
	}

	// Get only the channels we need
	channelIDs := lo.Map(results, func(item channelStats, _ int) int {
		return item.ChannelID
	})

	channels, err := r.client.Channel.Query().
		Where(channel.IDIn(channelIDs...)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get channels: %w", err)
	}

	// Create efficient lookup map
	channelMap := lo.SliceToMap(channels, func(ch *ent.Channel) (int, *ent.Channel) {
		return ch.ID, ch
	})

	// Build response efficiently
	var response []*RequestStatsByChannel

	for _, result := range results {
		if ch, exists := channelMap[result.ChannelID]; exists {
			response = append(response, &RequestStatsByChannel{
				ChannelName: ch.Name,
				ChannelType: string(ch.Type),
				Count:       result.Count,
			})
		}
	}

	return response, nil
}

// RequestStatsByModel is the resolver for the requestStatsByModel field.
func (r *queryResolver) RequestStatsByModel(ctx context.Context) ([]*RequestStatsByModel, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	type modelStats struct {
		ModelID string `json:"model_id"`
		Count   int    `json:"request_count"`
	}

	var results []modelStats

	err := r.client.Request.Query().
		GroupBy(request.FieldModelID).
		Aggregate(ent.As(ent.Count(), "request_count")).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get requests by model: %w", err)
	}

	stats := lo.Map(results, func(item modelStats, _ int) *RequestStatsByModel {
		return &RequestStatsByModel{
			ModelID: item.ModelID,
			Count:   item.Count,
		}
	})

	return stats, nil
}

// DailyRequestStats is the resolver for the dailyRequestStats field.
func (r *queryResolver) DailyRequestStats(ctx context.Context, days *int) ([]*DailyRequestStats, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	daysCount := 30
	if days != nil {
		daysCount = *days
		if daysCount <= 0 || daysCount > 365 {
			return nil, fmt.Errorf("invalid days parameter: must be between 1 and 365")
		}
	}

	now := time.Now()
	startDate := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location()).AddDate(0, 0, -daysCount+1)

	// Use GROUP BY aggregation for efficient database-level computation
	type dailyStats struct {
		Date  string `json:"date"`
		Count int    `json:"total_count"`
	}

	var results []dailyStats

	// Use raw SQL for complex GROUP BY with conditional counting
	err := r.client.Request.Query().
		Where(request.CreatedAtGTE(startDate), request.StatusEQ(request.StatusCompleted)).
		Modify(func(s *sql.Selector) {
			s.Select(
				sql.As("DATE(created_at)", "date"),
				sql.As(sql.Count("*"), "total_count"),
			).
				GroupBy("DATE(created_at)").
				OrderBy("date")
		}).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get daily request stats: %w", err)
	}

	// Create a map for fast lookup of aggregated data
	statsMap := lo.SliceToMap(results, func(item dailyStats) (string, dailyStats) {
		return item.Date, item
	})

	// Build complete response with zero values for missing dates
	response := make([]*DailyRequestStats, 0, daysCount)

	for i := range daysCount {
		date := startDate.AddDate(0, 0, i)
		dateStr := date.Format("2006-01-02")

		if stats, exists := statsMap[dateStr]; exists {
			// Use aggregated data from database
			response = append(response, &DailyRequestStats{
				Date:  dateStr,
				Count: stats.Count,
			})
		} else {
			// Fill missing dates with zero values
			response = append(response, &DailyRequestStats{
				Date:  dateStr,
				Count: 0,
			})
		}
	}

	return response, nil
}

// TopRequestsUsers is the resolver for the topRequestsUsers field.
func (r *queryResolver) TopRequestsUsers(ctx context.Context, limit *int) ([]*TopRequestsUsers, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	limitCount := 10
	if limit != nil {
		limitCount = *limit
		if limitCount <= 0 || limitCount > 100 {
			return nil, fmt.Errorf("invalid limit parameter: must be between 1 and 100")
		}
	}

	type userRequestCount struct {
		UserID       int `json:"user_id"`
		RequestCount int `json:"request_count"`
	}

	var results []userRequestCount

	// Use database aggregation without ordering (GroupBy doesn't support Order)
	err := r.client.Request.Query().
		Limit(limitCount).
		Modify(func(s *sql.Selector) {
			s.Select(
				request.FieldUserID,
				sql.As(sql.Count("*"), "request_count"),
			).
				GroupBy(request.FieldUserID).
				OrderBy(sql.Desc("request_count"))
		}).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get top users: %w", err)
	}

	if len(results) == 0 {
		return []*TopRequestsUsers{}, nil
	}

	// Get user details for the top users
	userIDs := lo.Map(results, func(item userRequestCount, _ int) int {
		return item.UserID
	})

	users, err := r.client.User.Query().
		Where(user.IDIn(userIDs...)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get user details: %w", err)
	}

	userMap := lo.SliceToMap(users, func(u *ent.User) (int, *ent.User) {
		return u.ID, u
	})

	// Build response with user details
	var response []*TopRequestsUsers

	for _, result := range results {
		if u, exists := userMap[result.UserID]; exists {
			fullName := u.FirstName
			if u.LastName != "" {
				fullName = fullName + " " + u.LastName
			}

			response = append(response, &TopRequestsUsers{
				UserID:       objects.GUID{Type: "User", ID: u.ID},
				UserName:     fullName,
				UserEmail:    u.Email,
				RequestCount: result.RequestCount,
			})
		}
	}

	return response, nil
}
