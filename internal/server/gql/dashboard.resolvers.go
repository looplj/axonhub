package gql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76-dev

import (
	"context"
	"fmt"
	"time"

	"github.com/samber/lo"
	"github.com/looplj/axonhub/internal/ent"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/log"
	"github.com/looplj/axonhub/internal/objects"
	"github.com/looplj/axonhub/internal/scopes"
)

// DashboardStats is the resolver for the dashboardStats field.
func (r *queryResolver) DashboardStats(ctx context.Context) (*DashboardStats, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	now := time.Now()
	today := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
	weekAgo := today.AddDate(0, 0, -7)
	monthAgo := today.AddDate(0, -1, 0)

	// Get total counts
	totalUsers, err := r.client.User.Query().Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count users", log.Cause(err))
		return nil, fmt.Errorf("failed to count users")
	}

	totalChannels, err := r.client.Channel.Query().Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count channels", log.Cause(err))
		return nil, fmt.Errorf("failed to count channels")
	}

	totalRequests, err := r.client.Request.Query().Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count requests")
	}

	totalAPIKeys, err := r.client.APIKey.Query().Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count API keys", log.Cause(err))
		return nil, fmt.Errorf("failed to count API keys")
	}

	// Get time-based counts
	requestsToday, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(today)).
		Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count today's requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count today's requests")
	}

	requestsThisWeek, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(weekAgo)).
		Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count this week's requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count this week's requests")
	}

	requestsThisMonth, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(monthAgo)).
		Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count this month's requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count this month's requests")
	}

	// Get status-based counts
	successfulRequests, err := r.client.Request.Query().
		Where(request.StatusEQ(request.StatusCompleted)).
		Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count successful requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count successful requests")
	}

	failedRequests, err := r.client.Request.Query().
		Where(request.StatusEQ(request.StatusFailed)).
		Count(ctx)
	if err != nil {
		log.Warn(ctx, "failed to count failed requests", log.Cause(err))
		return nil, fmt.Errorf("failed to count failed requests")
	}

	return &DashboardStats{
		TotalUsers:          totalUsers,
		TotalChannels:       totalChannels,
		TotalRequests:       totalRequests,
		TotalAPIKeys:        totalAPIKeys,
		RequestsToday:       requestsToday,
		RequestsThisWeek:    requestsThisWeek,
		RequestsThisMonth:   requestsThisMonth,
		SuccessfulRequests:  successfulRequests,
		FailedRequests:      failedRequests,
		AverageResponseTime: nil, // TODO: Calculate from request execution data
	}, nil
}

// RequestsByStatus is the resolver for the requestsByStatus field.
func (r *queryResolver) RequestsByStatus(ctx context.Context) ([]*RequestsByStatus, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	var results []RequestsByStatus

	err := r.client.Request.Query().
		GroupBy(request.FieldStatus).
		Aggregate(ent.Count()).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get requests by status: %w", err)
	}

	return lo.ToSlicePtr(results), nil
}

// RequestsByChannel is the resolver for the requestsByChannel field.
func (r *queryResolver) RequestsByChannel(ctx context.Context) ([]*RequestsByChannel, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	executions, err := r.client.RequestExecution.Query().
		WithRequest(func(q *ent.RequestQuery) {
			q.WithAPIKey(func(aq *ent.APIKeyQuery) {
				aq.WithUser()
			})
		}).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get request executions: %w", err)
	}

	// Get channel info
	channels, err := r.client.Channel.Query().All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get channels: %w", err)
	}

	channelMap := make(map[int]*ent.Channel)
	for _, ch := range channels {
		channelMap[ch.ID] = ch
	}

	// Count by channel
	channelCounts := make(map[int]int)
	for _, exec := range executions {
		channelCounts[exec.ChannelID]++
	}

	var response []*RequestsByChannel

	for channelID, count := range channelCounts {
		if ch, exists := channelMap[channelID]; exists {
			response = append(response, &RequestsByChannel{
				ChannelName: ch.Name,
				ChannelType: string(ch.Type),
				Count:       count,
			})
		}
	}

	return response, nil
}

// RequestsByModel is the resolver for the requestsByModel field.
func (r *queryResolver) RequestsByModel(ctx context.Context) ([]*RequestsByModel, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	type modelCount struct {
		ModelID string `json:"model_id"`
		Count   int    `json:"count"`
	}

	var results []modelCount

	err := r.client.RequestExecution.Query().
		GroupBy(requestexecution.FieldModelID).
		Aggregate(ent.Count()).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get requests by model: %w", err)
	}

	var response []*RequestsByModel
	for _, result := range results {
		response = append(response, &RequestsByModel{
			ModelID: result.ModelID,
			Count:   result.Count,
		})
	}

	return response, nil
}

// DailyRequestStats is the resolver for the dailyRequestStats field.
func (r *queryResolver) DailyRequestStats(ctx context.Context, days *int) ([]*DailyRequestStats, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	daysCount := 30
	if days != nil {
		daysCount = *days
	}

	now := time.Now()
	startDate := now.AddDate(0, 0, -daysCount)

	requests, err := r.client.Request.Query().
		Where(request.CreatedAtGTE(startDate)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get daily request stats: %w", err)
	}

	// Group by date
	dailyStats := make(map[string]*DailyRequestStats)

	for i := range daysCount {
		date := startDate.AddDate(0, 0, i)
		dateStr := date.Format("2006-01-02")
		dailyStats[dateStr] = &DailyRequestStats{
			Date:         dateStr,
			Count:        0,
			SuccessCount: 0,
			FailedCount:  0,
		}
	}

	for _, req := range requests {
		dateStr := req.CreatedAt.Format("2006-01-02")
		if stats, exists := dailyStats[dateStr]; exists {
			stats.Count++
			//nolint:exhaustive // Checkd.
			switch req.Status {
			case request.StatusCompleted:
				stats.SuccessCount++
			case request.StatusFailed:
				stats.FailedCount++
			}
		}
	}

	var response []*DailyRequestStats

	for i := range daysCount {
		date := startDate.AddDate(0, 0, i)

		dateStr := date.Format("2006-01-02")
		if stats, exists := dailyStats[dateStr]; exists {
			response = append(response, stats)
		}
	}

	return response, nil
}

// HourlyRequestStats is the resolver for the hourlyRequestStats field.
func (r *queryResolver) HourlyRequestStats(ctx context.Context, date *string) ([]*HourlyRequestStats, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	targetDate := time.Now()

	if date != nil {
		var err error

		targetDate, err = time.Parse("2006-01-02", *date)
		if err != nil {
			return nil, fmt.Errorf("invalid date format: %w", err)
		}
	}

	startOfDay := time.Date(
		targetDate.Year(),
		targetDate.Month(),
		targetDate.Day(),
		0,
		0,
		0,
		0,
		targetDate.Location(),
	)
	endOfDay := startOfDay.Add(24 * time.Hour)

	requests, err := r.client.Request.Query().
		Where(
			request.CreatedAtGTE(startOfDay),
			request.CreatedAtLT(endOfDay),
		).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get hourly request stats: %w", err)
	}

	// Initialize hourly stats
	hourlyStats := make(map[int]int)
	for i := range 24 {
		hourlyStats[i] = 0
	}

	// Count requests by hour
	for _, req := range requests {
		hour := req.CreatedAt.Hour()
		hourlyStats[hour]++
	}

	var response []*HourlyRequestStats
	for hour := range 24 {
		response = append(response, &HourlyRequestStats{
			Hour:  hour,
			Count: hourlyStats[hour],
		})
	}

	return response, nil
}

// TopUsers is the resolver for the topUsers field.
func (r *queryResolver) TopUsers(ctx context.Context, limit *int) ([]*TopUsers, error) {
	ctx = scopes.WithUserScopeDecision(ctx, scopes.ScopeReadDashboard)

	limitCount := 10
	if limit != nil {
		limitCount = *limit
	}

	type userRequestCount struct {
		UserID       int `json:"user_id"`
		RequestCount int `json:"request_count"`
	}

	var results []userRequestCount

	err := r.client.Request.Query().
		GroupBy(request.FieldUserID).
		Aggregate(ent.As(ent.Count(), "request_count")).
		Scan(ctx, &results)
	if err != nil {
		return nil, fmt.Errorf("failed to get top users: %w", err)
	}

	// Get user details
	users, err := r.client.User.Query().
		Where(user.IDIn(lo.Map(results, func(item userRequestCount, _ int) int {
			return item.UserID
		})...)).
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %w", err)
	}

	userMap := lo.SliceToMap(users, func(u *ent.User) (int, *ent.User) {
		return u.ID, u
	})

	// Combine data and sort by request count
	var response []*TopUsers

	for _, result := range results {
		if user, exists := userMap[result.UserID]; exists {
			fullName := user.FirstName
			if user.LastName != "" {
				fullName = fullName + " " + user.LastName
			}

			response = append(response, &TopUsers{
				UserID: objects.GUID{
					Type: "User",
					ID:   result.UserID,
				},
				UserName:     fullName,
				UserEmail:    user.Email,
				RequestCount: result.RequestCount,
			})
		}
	}

	// Sort by request count (descending) and limit
	if len(response) > limitCount {
		response = response[:limitCount]
	}

	return response, nil
}
