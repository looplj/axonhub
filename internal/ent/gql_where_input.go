// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/job"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/user"
)

// APIKeyWhereInput represents a where input for filtering APIKey queries.
type APIKeyWhereInput struct {
	Predicates []predicate.APIKey  `json:"-"`
	Not        *APIKeyWhereInput   `json:"not,omitempty"`
	Or         []*APIKeyWhereInput `json:"or,omitempty"`
	And        []*APIKeyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *apikey.Status  `json:"status,omitempty"`
	StatusNEQ   *apikey.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []apikey.Status `json:"statusIn,omitempty"`
	StatusNotIn []apikey.Status `json:"statusNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APIKeyWhereInput) AddPredicates(predicates ...predicate.APIKey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APIKeyWhereInput filter on the APIKeyQuery builder.
func (i *APIKeyWhereInput) Filter(q *APIKeyQuery) (*APIKeyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPIKeyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPIKeyWhereInput is returned in case the APIKeyWhereInput is empty.
var ErrEmptyAPIKeyWhereInput = errors.New("ent: empty predicate APIKeyWhereInput")

// P returns a predicate for filtering apikeys.
// An error is returned if the input is empty or invalid.
func (i *APIKeyWhereInput) P() (predicate.APIKey, error) {
	var predicates []predicate.APIKey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apikey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIKey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apikey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIKey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apikey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apikey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apikey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apikey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apikey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apikey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apikey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apikey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apikey.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apikey.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apikey.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apikey.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apikey.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apikey.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apikey.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apikey.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apikey.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apikey.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apikey.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apikey.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apikey.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apikey.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, apikey.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, apikey.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, apikey.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, apikey.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, apikey.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, apikey.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, apikey.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, apikey.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, apikey.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, apikey.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, apikey.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.Key != nil {
		predicates = append(predicates, apikey.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apikey.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apikey.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apikey.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apikey.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apikey.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apikey.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apikey.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, apikey.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, apikey.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, apikey.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, apikey.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, apikey.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apikey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apikey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apikey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apikey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apikey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apikey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apikey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apikey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apikey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apikey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apikey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apikey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apikey.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, apikey.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, apikey.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, apikey.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, apikey.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUser != nil {
		p := apikey.HasUser()
		if !*i.HasUser {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasUserWith(with...))
	}
	if i.HasRequests != nil {
		p := apikey.HasRequests()
		if !*i.HasRequests {
			p = apikey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apikey.HasRequestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPIKeyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apikey.And(predicates...), nil
	}
}

// ChannelWhereInput represents a where input for filtering Channel queries.
type ChannelWhereInput struct {
	Predicates []predicate.Channel  `json:"-"`
	Not        *ChannelWhereInput   `json:"not,omitempty"`
	Or         []*ChannelWhereInput `json:"or,omitempty"`
	And        []*ChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *channel.Type  `json:"type,omitempty"`
	TypeNEQ   *channel.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []channel.Type `json:"typeIn,omitempty"`
	TypeNotIn []channel.Type `json:"typeNotIn,omitempty"`

	// "base_url" field predicates.
	BaseURL             *string  `json:"baseURL,omitempty"`
	BaseURLNEQ          *string  `json:"baseURLNEQ,omitempty"`
	BaseURLIn           []string `json:"baseURLIn,omitempty"`
	BaseURLNotIn        []string `json:"baseURLNotIn,omitempty"`
	BaseURLGT           *string  `json:"baseURLGT,omitempty"`
	BaseURLGTE          *string  `json:"baseURLGTE,omitempty"`
	BaseURLLT           *string  `json:"baseURLLT,omitempty"`
	BaseURLLTE          *string  `json:"baseURLLTE,omitempty"`
	BaseURLContains     *string  `json:"baseURLContains,omitempty"`
	BaseURLHasPrefix    *string  `json:"baseURLHasPrefix,omitempty"`
	BaseURLHasSuffix    *string  `json:"baseURLHasSuffix,omitempty"`
	BaseURLIsNil        bool     `json:"baseURLIsNil,omitempty"`
	BaseURLNotNil       bool     `json:"baseURLNotNil,omitempty"`
	BaseURLEqualFold    *string  `json:"baseURLEqualFold,omitempty"`
	BaseURLContainsFold *string  `json:"baseURLContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "status" field predicates.
	Status      *channel.Status  `json:"status,omitempty"`
	StatusNEQ   *channel.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []channel.Status `json:"statusIn,omitempty"`
	StatusNotIn []channel.Status `json:"statusNotIn,omitempty"`

	// "default_test_model" field predicates.
	DefaultTestModel             *string  `json:"defaultTestModel,omitempty"`
	DefaultTestModelNEQ          *string  `json:"defaultTestModelNEQ,omitempty"`
	DefaultTestModelIn           []string `json:"defaultTestModelIn,omitempty"`
	DefaultTestModelNotIn        []string `json:"defaultTestModelNotIn,omitempty"`
	DefaultTestModelGT           *string  `json:"defaultTestModelGT,omitempty"`
	DefaultTestModelGTE          *string  `json:"defaultTestModelGTE,omitempty"`
	DefaultTestModelLT           *string  `json:"defaultTestModelLT,omitempty"`
	DefaultTestModelLTE          *string  `json:"defaultTestModelLTE,omitempty"`
	DefaultTestModelContains     *string  `json:"defaultTestModelContains,omitempty"`
	DefaultTestModelHasPrefix    *string  `json:"defaultTestModelHasPrefix,omitempty"`
	DefaultTestModelHasSuffix    *string  `json:"defaultTestModelHasSuffix,omitempty"`
	DefaultTestModelEqualFold    *string  `json:"defaultTestModelEqualFold,omitempty"`
	DefaultTestModelContainsFold *string  `json:"defaultTestModelContainsFold,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelWhereInput) AddPredicates(predicates ...predicate.Channel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelWhereInput filter on the ChannelQuery builder.
func (i *ChannelWhereInput) Filter(q *ChannelQuery) (*ChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelWhereInput is returned in case the ChannelWhereInput is empty.
var ErrEmptyChannelWhereInput = errors.New("ent: empty predicate ChannelWhereInput")

// P returns a predicate for filtering channels.
// An error is returned if the input is empty or invalid.
func (i *ChannelWhereInput) P() (predicate.Channel, error) {
	var predicates []predicate.Channel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Channel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Channel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channel.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, channel.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, channel.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, channel.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, channel.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, channel.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, channel.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, channel.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, channel.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, channel.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, channel.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, channel.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, channel.TypeNotIn(i.TypeNotIn...))
	}
	if i.BaseURL != nil {
		predicates = append(predicates, channel.BaseURLEQ(*i.BaseURL))
	}
	if i.BaseURLNEQ != nil {
		predicates = append(predicates, channel.BaseURLNEQ(*i.BaseURLNEQ))
	}
	if len(i.BaseURLIn) > 0 {
		predicates = append(predicates, channel.BaseURLIn(i.BaseURLIn...))
	}
	if len(i.BaseURLNotIn) > 0 {
		predicates = append(predicates, channel.BaseURLNotIn(i.BaseURLNotIn...))
	}
	if i.BaseURLGT != nil {
		predicates = append(predicates, channel.BaseURLGT(*i.BaseURLGT))
	}
	if i.BaseURLGTE != nil {
		predicates = append(predicates, channel.BaseURLGTE(*i.BaseURLGTE))
	}
	if i.BaseURLLT != nil {
		predicates = append(predicates, channel.BaseURLLT(*i.BaseURLLT))
	}
	if i.BaseURLLTE != nil {
		predicates = append(predicates, channel.BaseURLLTE(*i.BaseURLLTE))
	}
	if i.BaseURLContains != nil {
		predicates = append(predicates, channel.BaseURLContains(*i.BaseURLContains))
	}
	if i.BaseURLHasPrefix != nil {
		predicates = append(predicates, channel.BaseURLHasPrefix(*i.BaseURLHasPrefix))
	}
	if i.BaseURLHasSuffix != nil {
		predicates = append(predicates, channel.BaseURLHasSuffix(*i.BaseURLHasSuffix))
	}
	if i.BaseURLIsNil {
		predicates = append(predicates, channel.BaseURLIsNil())
	}
	if i.BaseURLNotNil {
		predicates = append(predicates, channel.BaseURLNotNil())
	}
	if i.BaseURLEqualFold != nil {
		predicates = append(predicates, channel.BaseURLEqualFold(*i.BaseURLEqualFold))
	}
	if i.BaseURLContainsFold != nil {
		predicates = append(predicates, channel.BaseURLContainsFold(*i.BaseURLContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, channel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channel.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, channel.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, channel.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, channel.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, channel.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, channel.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, channel.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, channel.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, channel.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, channel.NameContainsFold(*i.NameContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, channel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, channel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, channel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, channel.StatusNotIn(i.StatusNotIn...))
	}
	if i.DefaultTestModel != nil {
		predicates = append(predicates, channel.DefaultTestModelEQ(*i.DefaultTestModel))
	}
	if i.DefaultTestModelNEQ != nil {
		predicates = append(predicates, channel.DefaultTestModelNEQ(*i.DefaultTestModelNEQ))
	}
	if len(i.DefaultTestModelIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelIn(i.DefaultTestModelIn...))
	}
	if len(i.DefaultTestModelNotIn) > 0 {
		predicates = append(predicates, channel.DefaultTestModelNotIn(i.DefaultTestModelNotIn...))
	}
	if i.DefaultTestModelGT != nil {
		predicates = append(predicates, channel.DefaultTestModelGT(*i.DefaultTestModelGT))
	}
	if i.DefaultTestModelGTE != nil {
		predicates = append(predicates, channel.DefaultTestModelGTE(*i.DefaultTestModelGTE))
	}
	if i.DefaultTestModelLT != nil {
		predicates = append(predicates, channel.DefaultTestModelLT(*i.DefaultTestModelLT))
	}
	if i.DefaultTestModelLTE != nil {
		predicates = append(predicates, channel.DefaultTestModelLTE(*i.DefaultTestModelLTE))
	}
	if i.DefaultTestModelContains != nil {
		predicates = append(predicates, channel.DefaultTestModelContains(*i.DefaultTestModelContains))
	}
	if i.DefaultTestModelHasPrefix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasPrefix(*i.DefaultTestModelHasPrefix))
	}
	if i.DefaultTestModelHasSuffix != nil {
		predicates = append(predicates, channel.DefaultTestModelHasSuffix(*i.DefaultTestModelHasSuffix))
	}
	if i.DefaultTestModelEqualFold != nil {
		predicates = append(predicates, channel.DefaultTestModelEqualFold(*i.DefaultTestModelEqualFold))
	}
	if i.DefaultTestModelContainsFold != nil {
		predicates = append(predicates, channel.DefaultTestModelContainsFold(*i.DefaultTestModelContainsFold))
	}

	if i.HasRequests != nil {
		p := channel.HasRequests()
		if !*i.HasRequests {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasRequestsWith(with...))
	}
	if i.HasExecutions != nil {
		p := channel.HasExecutions()
		if !*i.HasExecutions {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channel.And(predicates...), nil
	}
}

// JobWhereInput represents a where input for filtering Job queries.
type JobWhereInput struct {
	Predicates []predicate.Job  `json:"-"`
	Not        *JobWhereInput   `json:"not,omitempty"`
	Or         []*JobWhereInput `json:"or,omitempty"`
	And        []*JobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "owner_id" field predicates.
	OwnerID      *int  `json:"ownerID,omitempty"`
	OwnerIDNEQ   *int  `json:"ownerIDNEQ,omitempty"`
	OwnerIDIn    []int `json:"ownerIDIn,omitempty"`
	OwnerIDNotIn []int `json:"ownerIDNotIn,omitempty"`
	OwnerIDGT    *int  `json:"ownerIDGT,omitempty"`
	OwnerIDGTE   *int  `json:"ownerIDGTE,omitempty"`
	OwnerIDLT    *int  `json:"ownerIDLT,omitempty"`
	OwnerIDLTE   *int  `json:"ownerIDLTE,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "context" field predicates.
	Context             *string  `json:"context,omitempty"`
	ContextNEQ          *string  `json:"contextNEQ,omitempty"`
	ContextIn           []string `json:"contextIn,omitempty"`
	ContextNotIn        []string `json:"contextNotIn,omitempty"`
	ContextGT           *string  `json:"contextGT,omitempty"`
	ContextGTE          *string  `json:"contextGTE,omitempty"`
	ContextLT           *string  `json:"contextLT,omitempty"`
	ContextLTE          *string  `json:"contextLTE,omitempty"`
	ContextContains     *string  `json:"contextContains,omitempty"`
	ContextHasPrefix    *string  `json:"contextHasPrefix,omitempty"`
	ContextHasSuffix    *string  `json:"contextHasSuffix,omitempty"`
	ContextEqualFold    *string  `json:"contextEqualFold,omitempty"`
	ContextContainsFold *string  `json:"contextContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobWhereInput) AddPredicates(predicates ...predicate.Job) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobWhereInput filter on the JobQuery builder.
func (i *JobWhereInput) Filter(q *JobQuery) (*JobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobWhereInput is returned in case the JobWhereInput is empty.
var ErrEmptyJobWhereInput = errors.New("ent: empty predicate JobWhereInput")

// P returns a predicate for filtering jobs.
// An error is returned if the input is empty or invalid.
func (i *JobWhereInput) P() (predicate.Job, error) {
	var predicates []predicate.Job
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, job.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Job, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, job.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Job, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, job.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, job.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, job.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, job.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, job.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, job.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, job.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, job.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, job.IDLTE(*i.IDLTE))
	}
	if i.OwnerID != nil {
		predicates = append(predicates, job.OwnerIDEQ(*i.OwnerID))
	}
	if i.OwnerIDNEQ != nil {
		predicates = append(predicates, job.OwnerIDNEQ(*i.OwnerIDNEQ))
	}
	if len(i.OwnerIDIn) > 0 {
		predicates = append(predicates, job.OwnerIDIn(i.OwnerIDIn...))
	}
	if len(i.OwnerIDNotIn) > 0 {
		predicates = append(predicates, job.OwnerIDNotIn(i.OwnerIDNotIn...))
	}
	if i.OwnerIDGT != nil {
		predicates = append(predicates, job.OwnerIDGT(*i.OwnerIDGT))
	}
	if i.OwnerIDGTE != nil {
		predicates = append(predicates, job.OwnerIDGTE(*i.OwnerIDGTE))
	}
	if i.OwnerIDLT != nil {
		predicates = append(predicates, job.OwnerIDLT(*i.OwnerIDLT))
	}
	if i.OwnerIDLTE != nil {
		predicates = append(predicates, job.OwnerIDLTE(*i.OwnerIDLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, job.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, job.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, job.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, job.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, job.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, job.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, job.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, job.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, job.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, job.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, job.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, job.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, job.TypeContainsFold(*i.TypeContainsFold))
	}
	if i.Context != nil {
		predicates = append(predicates, job.ContextEQ(*i.Context))
	}
	if i.ContextNEQ != nil {
		predicates = append(predicates, job.ContextNEQ(*i.ContextNEQ))
	}
	if len(i.ContextIn) > 0 {
		predicates = append(predicates, job.ContextIn(i.ContextIn...))
	}
	if len(i.ContextNotIn) > 0 {
		predicates = append(predicates, job.ContextNotIn(i.ContextNotIn...))
	}
	if i.ContextGT != nil {
		predicates = append(predicates, job.ContextGT(*i.ContextGT))
	}
	if i.ContextGTE != nil {
		predicates = append(predicates, job.ContextGTE(*i.ContextGTE))
	}
	if i.ContextLT != nil {
		predicates = append(predicates, job.ContextLT(*i.ContextLT))
	}
	if i.ContextLTE != nil {
		predicates = append(predicates, job.ContextLTE(*i.ContextLTE))
	}
	if i.ContextContains != nil {
		predicates = append(predicates, job.ContextContains(*i.ContextContains))
	}
	if i.ContextHasPrefix != nil {
		predicates = append(predicates, job.ContextHasPrefix(*i.ContextHasPrefix))
	}
	if i.ContextHasSuffix != nil {
		predicates = append(predicates, job.ContextHasSuffix(*i.ContextHasSuffix))
	}
	if i.ContextEqualFold != nil {
		predicates = append(predicates, job.ContextEqualFold(*i.ContextEqualFold))
	}
	if i.ContextContainsFold != nil {
		predicates = append(predicates, job.ContextContainsFold(*i.ContextContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return job.And(predicates...), nil
	}
}

// RequestWhereInput represents a where input for filtering Request queries.
type RequestWhereInput struct {
	Predicates []predicate.Request  `json:"-"`
	Not        *RequestWhereInput   `json:"not,omitempty"`
	Or         []*RequestWhereInput `json:"or,omitempty"`
	And        []*RequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`

	// "api_key_id" field predicates.
	APIKeyID       *int  `json:"apiKeyID,omitempty"`
	APIKeyIDNEQ    *int  `json:"apiKeyIDNEQ,omitempty"`
	APIKeyIDIn     []int `json:"apiKeyIDIn,omitempty"`
	APIKeyIDNotIn  []int `json:"apiKeyIDNotIn,omitempty"`
	APIKeyIDIsNil  bool  `json:"apiKeyIDIsNil,omitempty"`
	APIKeyIDNotNil bool  `json:"apiKeyIDNotNil,omitempty"`

	// "source" field predicates.
	Source      *request.Source  `json:"source,omitempty"`
	SourceNEQ   *request.Source  `json:"sourceNEQ,omitempty"`
	SourceIn    []request.Source `json:"sourceIn,omitempty"`
	SourceNotIn []request.Source `json:"sourceNotIn,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "status" field predicates.
	Status      *request.Status  `json:"status,omitempty"`
	StatusNEQ   *request.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []request.Status `json:"statusIn,omitempty"`
	StatusNotIn []request.Status `json:"statusNotIn,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "api_key" edge predicates.
	HasAPIKey     *bool               `json:"hasAPIKey,omitempty"`
	HasAPIKeyWith []*APIKeyWhereInput `json:"hasAPIKeyWith,omitempty"`

	// "executions" edge predicates.
	HasExecutions     *bool                         `json:"hasExecutions,omitempty"`
	HasExecutionsWith []*RequestExecutionWhereInput `json:"hasExecutionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestWhereInput) AddPredicates(predicates ...predicate.Request) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestWhereInput filter on the RequestQuery builder.
func (i *RequestWhereInput) Filter(q *RequestQuery) (*RequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestWhereInput is returned in case the RequestWhereInput is empty.
var ErrEmptyRequestWhereInput = errors.New("ent: empty predicate RequestWhereInput")

// P returns a predicate for filtering requests.
// An error is returned if the input is empty or invalid.
func (i *RequestWhereInput) P() (predicate.Request, error) {
	var predicates []predicate.Request
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, request.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Request, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, request.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Request, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, request.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, request.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, request.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, request.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, request.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, request.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, request.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, request.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, request.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, request.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, request.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, request.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, request.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, request.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, request.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, request.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, request.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, request.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, request.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, request.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, request.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, request.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, request.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, request.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, request.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, request.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, request.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, request.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, request.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, request.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, request.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, request.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, request.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, request.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, request.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, request.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, request.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.APIKeyID != nil {
		predicates = append(predicates, request.APIKeyIDEQ(*i.APIKeyID))
	}
	if i.APIKeyIDNEQ != nil {
		predicates = append(predicates, request.APIKeyIDNEQ(*i.APIKeyIDNEQ))
	}
	if len(i.APIKeyIDIn) > 0 {
		predicates = append(predicates, request.APIKeyIDIn(i.APIKeyIDIn...))
	}
	if len(i.APIKeyIDNotIn) > 0 {
		predicates = append(predicates, request.APIKeyIDNotIn(i.APIKeyIDNotIn...))
	}
	if i.APIKeyIDIsNil {
		predicates = append(predicates, request.APIKeyIDIsNil())
	}
	if i.APIKeyIDNotNil {
		predicates = append(predicates, request.APIKeyIDNotNil())
	}
	if i.Source != nil {
		predicates = append(predicates, request.SourceEQ(*i.Source))
	}
	if i.SourceNEQ != nil {
		predicates = append(predicates, request.SourceNEQ(*i.SourceNEQ))
	}
	if len(i.SourceIn) > 0 {
		predicates = append(predicates, request.SourceIn(i.SourceIn...))
	}
	if len(i.SourceNotIn) > 0 {
		predicates = append(predicates, request.SourceNotIn(i.SourceNotIn...))
	}
	if i.ModelID != nil {
		predicates = append(predicates, request.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, request.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, request.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, request.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, request.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, request.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, request.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, request.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, request.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, request.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, request.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, request.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, request.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, request.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, request.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, request.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, request.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, request.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, request.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, request.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, request.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, request.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, request.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, request.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, request.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, request.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, request.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, request.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, request.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, request.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasUser != nil {
		p := request.HasUser()
		if !*i.HasUser {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasUserWith(with...))
	}
	if i.HasAPIKey != nil {
		p := request.HasAPIKey()
		if !*i.HasAPIKey {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeyWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeyWith))
		for _, w := range i.HasAPIKeyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasAPIKeyWith(with...))
	}
	if i.HasExecutions != nil {
		p := request.HasExecutions()
		if !*i.HasExecutions {
			p = request.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExecutionsWith) > 0 {
		with := make([]predicate.RequestExecution, 0, len(i.HasExecutionsWith))
		for _, w := range i.HasExecutionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasExecutionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, request.HasExecutionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return request.And(predicates...), nil
	}
}

// RequestExecutionWhereInput represents a where input for filtering RequestExecution queries.
type RequestExecutionWhereInput struct {
	Predicates []predicate.RequestExecution  `json:"-"`
	Not        *RequestExecutionWhereInput   `json:"not,omitempty"`
	Or         []*RequestExecutionWhereInput `json:"or,omitempty"`
	And        []*RequestExecutionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "user_id" field predicates.
	UserID      *int  `json:"userID,omitempty"`
	UserIDNEQ   *int  `json:"userIDNEQ,omitempty"`
	UserIDIn    []int `json:"userIDIn,omitempty"`
	UserIDNotIn []int `json:"userIDNotIn,omitempty"`
	UserIDGT    *int  `json:"userIDGT,omitempty"`
	UserIDGTE   *int  `json:"userIDGTE,omitempty"`
	UserIDLT    *int  `json:"userIDLT,omitempty"`
	UserIDLTE   *int  `json:"userIDLTE,omitempty"`

	// "request_id" field predicates.
	RequestID      *int  `json:"requestID,omitempty"`
	RequestIDNEQ   *int  `json:"requestIDNEQ,omitempty"`
	RequestIDIn    []int `json:"requestIDIn,omitempty"`
	RequestIDNotIn []int `json:"requestIDNotIn,omitempty"`

	// "channel_id" field predicates.
	ChannelID      *int  `json:"channelID,omitempty"`
	ChannelIDNEQ   *int  `json:"channelIDNEQ,omitempty"`
	ChannelIDIn    []int `json:"channelIDIn,omitempty"`
	ChannelIDNotIn []int `json:"channelIDNotIn,omitempty"`

	// "model_id" field predicates.
	ModelID             *string  `json:"modelID,omitempty"`
	ModelIDNEQ          *string  `json:"modelIDNEQ,omitempty"`
	ModelIDIn           []string `json:"modelIDIn,omitempty"`
	ModelIDNotIn        []string `json:"modelIDNotIn,omitempty"`
	ModelIDGT           *string  `json:"modelIDGT,omitempty"`
	ModelIDGTE          *string  `json:"modelIDGTE,omitempty"`
	ModelIDLT           *string  `json:"modelIDLT,omitempty"`
	ModelIDLTE          *string  `json:"modelIDLTE,omitempty"`
	ModelIDContains     *string  `json:"modelIDContains,omitempty"`
	ModelIDHasPrefix    *string  `json:"modelIDHasPrefix,omitempty"`
	ModelIDHasSuffix    *string  `json:"modelIDHasSuffix,omitempty"`
	ModelIDEqualFold    *string  `json:"modelIDEqualFold,omitempty"`
	ModelIDContainsFold *string  `json:"modelIDContainsFold,omitempty"`

	// "format" field predicates.
	Format             *string  `json:"format,omitempty"`
	FormatNEQ          *string  `json:"formatNEQ,omitempty"`
	FormatIn           []string `json:"formatIn,omitempty"`
	FormatNotIn        []string `json:"formatNotIn,omitempty"`
	FormatGT           *string  `json:"formatGT,omitempty"`
	FormatGTE          *string  `json:"formatGTE,omitempty"`
	FormatLT           *string  `json:"formatLT,omitempty"`
	FormatLTE          *string  `json:"formatLTE,omitempty"`
	FormatContains     *string  `json:"formatContains,omitempty"`
	FormatHasPrefix    *string  `json:"formatHasPrefix,omitempty"`
	FormatHasSuffix    *string  `json:"formatHasSuffix,omitempty"`
	FormatEqualFold    *string  `json:"formatEqualFold,omitempty"`
	FormatContainsFold *string  `json:"formatContainsFold,omitempty"`

	// "error_message" field predicates.
	ErrorMessage             *string  `json:"errorMessage,omitempty"`
	ErrorMessageNEQ          *string  `json:"errorMessageNEQ,omitempty"`
	ErrorMessageIn           []string `json:"errorMessageIn,omitempty"`
	ErrorMessageNotIn        []string `json:"errorMessageNotIn,omitempty"`
	ErrorMessageGT           *string  `json:"errorMessageGT,omitempty"`
	ErrorMessageGTE          *string  `json:"errorMessageGTE,omitempty"`
	ErrorMessageLT           *string  `json:"errorMessageLT,omitempty"`
	ErrorMessageLTE          *string  `json:"errorMessageLTE,omitempty"`
	ErrorMessageContains     *string  `json:"errorMessageContains,omitempty"`
	ErrorMessageHasPrefix    *string  `json:"errorMessageHasPrefix,omitempty"`
	ErrorMessageHasSuffix    *string  `json:"errorMessageHasSuffix,omitempty"`
	ErrorMessageIsNil        bool     `json:"errorMessageIsNil,omitempty"`
	ErrorMessageNotNil       bool     `json:"errorMessageNotNil,omitempty"`
	ErrorMessageEqualFold    *string  `json:"errorMessageEqualFold,omitempty"`
	ErrorMessageContainsFold *string  `json:"errorMessageContainsFold,omitempty"`

	// "status" field predicates.
	Status      *requestexecution.Status  `json:"status,omitempty"`
	StatusNEQ   *requestexecution.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []requestexecution.Status `json:"statusIn,omitempty"`
	StatusNotIn []requestexecution.Status `json:"statusNotIn,omitempty"`

	// "request" edge predicates.
	HasRequest     *bool                `json:"hasRequest,omitempty"`
	HasRequestWith []*RequestWhereInput `json:"hasRequestWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RequestExecutionWhereInput) AddPredicates(predicates ...predicate.RequestExecution) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RequestExecutionWhereInput filter on the RequestExecutionQuery builder.
func (i *RequestExecutionWhereInput) Filter(q *RequestExecutionQuery) (*RequestExecutionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRequestExecutionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRequestExecutionWhereInput is returned in case the RequestExecutionWhereInput is empty.
var ErrEmptyRequestExecutionWhereInput = errors.New("ent: empty predicate RequestExecutionWhereInput")

// P returns a predicate for filtering requestexecutions.
// An error is returned if the input is empty or invalid.
func (i *RequestExecutionWhereInput) P() (predicate.RequestExecution, error) {
	var predicates []predicate.RequestExecution
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, requestexecution.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, requestexecution.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.RequestExecution, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, requestexecution.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, requestexecution.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, requestexecution.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, requestexecution.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, requestexecution.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, requestexecution.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, requestexecution.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, requestexecution.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, requestexecution.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, requestexecution.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, requestexecution.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, requestexecution.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, requestexecution.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, requestexecution.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, requestexecution.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, requestexecution.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, requestexecution.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UserID != nil {
		predicates = append(predicates, requestexecution.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, requestexecution.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, requestexecution.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, requestexecution.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, requestexecution.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, requestexecution.UserIDLTE(*i.UserIDLTE))
	}
	if i.RequestID != nil {
		predicates = append(predicates, requestexecution.RequestIDEQ(*i.RequestID))
	}
	if i.RequestIDNEQ != nil {
		predicates = append(predicates, requestexecution.RequestIDNEQ(*i.RequestIDNEQ))
	}
	if len(i.RequestIDIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDIn(i.RequestIDIn...))
	}
	if len(i.RequestIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.RequestIDNotIn(i.RequestIDNotIn...))
	}
	if i.ChannelID != nil {
		predicates = append(predicates, requestexecution.ChannelIDEQ(*i.ChannelID))
	}
	if i.ChannelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ChannelIDNEQ(*i.ChannelIDNEQ))
	}
	if len(i.ChannelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDIn(i.ChannelIDIn...))
	}
	if len(i.ChannelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ChannelIDNotIn(i.ChannelIDNotIn...))
	}
	if i.ModelID != nil {
		predicates = append(predicates, requestexecution.ModelIDEQ(*i.ModelID))
	}
	if i.ModelIDNEQ != nil {
		predicates = append(predicates, requestexecution.ModelIDNEQ(*i.ModelIDNEQ))
	}
	if len(i.ModelIDIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDIn(i.ModelIDIn...))
	}
	if len(i.ModelIDNotIn) > 0 {
		predicates = append(predicates, requestexecution.ModelIDNotIn(i.ModelIDNotIn...))
	}
	if i.ModelIDGT != nil {
		predicates = append(predicates, requestexecution.ModelIDGT(*i.ModelIDGT))
	}
	if i.ModelIDGTE != nil {
		predicates = append(predicates, requestexecution.ModelIDGTE(*i.ModelIDGTE))
	}
	if i.ModelIDLT != nil {
		predicates = append(predicates, requestexecution.ModelIDLT(*i.ModelIDLT))
	}
	if i.ModelIDLTE != nil {
		predicates = append(predicates, requestexecution.ModelIDLTE(*i.ModelIDLTE))
	}
	if i.ModelIDContains != nil {
		predicates = append(predicates, requestexecution.ModelIDContains(*i.ModelIDContains))
	}
	if i.ModelIDHasPrefix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasPrefix(*i.ModelIDHasPrefix))
	}
	if i.ModelIDHasSuffix != nil {
		predicates = append(predicates, requestexecution.ModelIDHasSuffix(*i.ModelIDHasSuffix))
	}
	if i.ModelIDEqualFold != nil {
		predicates = append(predicates, requestexecution.ModelIDEqualFold(*i.ModelIDEqualFold))
	}
	if i.ModelIDContainsFold != nil {
		predicates = append(predicates, requestexecution.ModelIDContainsFold(*i.ModelIDContainsFold))
	}
	if i.Format != nil {
		predicates = append(predicates, requestexecution.FormatEQ(*i.Format))
	}
	if i.FormatNEQ != nil {
		predicates = append(predicates, requestexecution.FormatNEQ(*i.FormatNEQ))
	}
	if len(i.FormatIn) > 0 {
		predicates = append(predicates, requestexecution.FormatIn(i.FormatIn...))
	}
	if len(i.FormatNotIn) > 0 {
		predicates = append(predicates, requestexecution.FormatNotIn(i.FormatNotIn...))
	}
	if i.FormatGT != nil {
		predicates = append(predicates, requestexecution.FormatGT(*i.FormatGT))
	}
	if i.FormatGTE != nil {
		predicates = append(predicates, requestexecution.FormatGTE(*i.FormatGTE))
	}
	if i.FormatLT != nil {
		predicates = append(predicates, requestexecution.FormatLT(*i.FormatLT))
	}
	if i.FormatLTE != nil {
		predicates = append(predicates, requestexecution.FormatLTE(*i.FormatLTE))
	}
	if i.FormatContains != nil {
		predicates = append(predicates, requestexecution.FormatContains(*i.FormatContains))
	}
	if i.FormatHasPrefix != nil {
		predicates = append(predicates, requestexecution.FormatHasPrefix(*i.FormatHasPrefix))
	}
	if i.FormatHasSuffix != nil {
		predicates = append(predicates, requestexecution.FormatHasSuffix(*i.FormatHasSuffix))
	}
	if i.FormatEqualFold != nil {
		predicates = append(predicates, requestexecution.FormatEqualFold(*i.FormatEqualFold))
	}
	if i.FormatContainsFold != nil {
		predicates = append(predicates, requestexecution.FormatContainsFold(*i.FormatContainsFold))
	}
	if i.ErrorMessage != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEQ(*i.ErrorMessage))
	}
	if i.ErrorMessageNEQ != nil {
		predicates = append(predicates, requestexecution.ErrorMessageNEQ(*i.ErrorMessageNEQ))
	}
	if len(i.ErrorMessageIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageIn(i.ErrorMessageIn...))
	}
	if len(i.ErrorMessageNotIn) > 0 {
		predicates = append(predicates, requestexecution.ErrorMessageNotIn(i.ErrorMessageNotIn...))
	}
	if i.ErrorMessageGT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGT(*i.ErrorMessageGT))
	}
	if i.ErrorMessageGTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageGTE(*i.ErrorMessageGTE))
	}
	if i.ErrorMessageLT != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLT(*i.ErrorMessageLT))
	}
	if i.ErrorMessageLTE != nil {
		predicates = append(predicates, requestexecution.ErrorMessageLTE(*i.ErrorMessageLTE))
	}
	if i.ErrorMessageContains != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContains(*i.ErrorMessageContains))
	}
	if i.ErrorMessageHasPrefix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasPrefix(*i.ErrorMessageHasPrefix))
	}
	if i.ErrorMessageHasSuffix != nil {
		predicates = append(predicates, requestexecution.ErrorMessageHasSuffix(*i.ErrorMessageHasSuffix))
	}
	if i.ErrorMessageIsNil {
		predicates = append(predicates, requestexecution.ErrorMessageIsNil())
	}
	if i.ErrorMessageNotNil {
		predicates = append(predicates, requestexecution.ErrorMessageNotNil())
	}
	if i.ErrorMessageEqualFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageEqualFold(*i.ErrorMessageEqualFold))
	}
	if i.ErrorMessageContainsFold != nil {
		predicates = append(predicates, requestexecution.ErrorMessageContainsFold(*i.ErrorMessageContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, requestexecution.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, requestexecution.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, requestexecution.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, requestexecution.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasRequest != nil {
		p := requestexecution.HasRequest()
		if !*i.HasRequest {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestWith))
		for _, w := range i.HasRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasRequestWith(with...))
	}
	if i.HasChannel != nil {
		p := requestexecution.HasChannel()
		if !*i.HasChannel {
			p = requestexecution.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, requestexecution.HasChannelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRequestExecutionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return requestexecution.And(predicates...), nil
	}
}

// RoleWhereInput represents a where input for filtering Role queries.
type RoleWhereInput struct {
	Predicates []predicate.Role  `json:"-"`
	Not        *RoleWhereInput   `json:"not,omitempty"`
	Or         []*RoleWhereInput `json:"or,omitempty"`
	And        []*RoleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *RoleWhereInput) AddPredicates(predicates ...predicate.Role) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the RoleWhereInput filter on the RoleQuery builder.
func (i *RoleWhereInput) Filter(q *RoleQuery) (*RoleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyRoleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyRoleWhereInput is returned in case the RoleWhereInput is empty.
var ErrEmptyRoleWhereInput = errors.New("ent: empty predicate RoleWhereInput")

// P returns a predicate for filtering roles.
// An error is returned if the input is empty or invalid.
func (i *RoleWhereInput) P() (predicate.Role, error) {
	var predicates []predicate.Role
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, role.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Role, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, role.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Role, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, role.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, role.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, role.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, role.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, role.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, role.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, role.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, role.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, role.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, role.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, role.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, role.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, role.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, role.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, role.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, role.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, role.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, role.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, role.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, role.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, role.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, role.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, role.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, role.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, role.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, role.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, role.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, role.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, role.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, role.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, role.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, role.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, role.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, role.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, role.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, role.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, role.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, role.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, role.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, role.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, role.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, role.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, role.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, role.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, role.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, role.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, role.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, role.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, role.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, role.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, role.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, role.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, role.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, role.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, role.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, role.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, role.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, role.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, role.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasUsers != nil {
		p := role.HasUsers()
		if !*i.HasUsers {
			p = role.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, role.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyRoleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return role.And(predicates...), nil
	}
}

// SystemWhereInput represents a where input for filtering System queries.
type SystemWhereInput struct {
	Predicates []predicate.System  `json:"-"`
	Not        *SystemWhereInput   `json:"not,omitempty"`
	Or         []*SystemWhereInput `json:"or,omitempty"`
	And        []*SystemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SystemWhereInput) AddPredicates(predicates ...predicate.System) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SystemWhereInput filter on the SystemQuery builder.
func (i *SystemWhereInput) Filter(q *SystemQuery) (*SystemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySystemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySystemWhereInput is returned in case the SystemWhereInput is empty.
var ErrEmptySystemWhereInput = errors.New("ent: empty predicate SystemWhereInput")

// P returns a predicate for filtering systems.
// An error is returned if the input is empty or invalid.
func (i *SystemWhereInput) P() (predicate.System, error) {
	var predicates []predicate.System
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, system.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.System, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, system.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.System, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, system.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, system.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, system.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, system.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, system.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, system.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, system.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, system.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, system.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, system.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, system.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, system.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, system.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, system.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, system.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, system.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, system.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, system.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, system.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, system.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, system.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, system.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, system.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, system.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, system.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, system.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, system.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, system.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, system.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, system.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, system.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, system.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, system.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Key != nil {
		predicates = append(predicates, system.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, system.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, system.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, system.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, system.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, system.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, system.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, system.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, system.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, system.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, system.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, system.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, system.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, system.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, system.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, system.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, system.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, system.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, system.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, system.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, system.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, system.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, system.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, system.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, system.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, system.ValueContainsFold(*i.ValueContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySystemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return system.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt      *int  `json:"deletedAt,omitempty"`
	DeletedAtNEQ   *int  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn    []int `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn []int `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT    *int  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE   *int  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT    *int  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE   *int  `json:"deletedAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "status" field predicates.
	Status      *user.Status  `json:"status,omitempty"`
	StatusNEQ   *user.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []user.Status `json:"statusIn,omitempty"`
	StatusNotIn []user.Status `json:"statusNotIn,omitempty"`

	// "prefer_language" field predicates.
	PreferLanguage             *string  `json:"preferLanguage,omitempty"`
	PreferLanguageNEQ          *string  `json:"preferLanguageNEQ,omitempty"`
	PreferLanguageIn           []string `json:"preferLanguageIn,omitempty"`
	PreferLanguageNotIn        []string `json:"preferLanguageNotIn,omitempty"`
	PreferLanguageGT           *string  `json:"preferLanguageGT,omitempty"`
	PreferLanguageGTE          *string  `json:"preferLanguageGTE,omitempty"`
	PreferLanguageLT           *string  `json:"preferLanguageLT,omitempty"`
	PreferLanguageLTE          *string  `json:"preferLanguageLTE,omitempty"`
	PreferLanguageContains     *string  `json:"preferLanguageContains,omitempty"`
	PreferLanguageHasPrefix    *string  `json:"preferLanguageHasPrefix,omitempty"`
	PreferLanguageHasSuffix    *string  `json:"preferLanguageHasSuffix,omitempty"`
	PreferLanguageEqualFold    *string  `json:"preferLanguageEqualFold,omitempty"`
	PreferLanguageContainsFold *string  `json:"preferLanguageContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "avatar" field predicates.
	Avatar             *string  `json:"avatar,omitempty"`
	AvatarNEQ          *string  `json:"avatarNEQ,omitempty"`
	AvatarIn           []string `json:"avatarIn,omitempty"`
	AvatarNotIn        []string `json:"avatarNotIn,omitempty"`
	AvatarGT           *string  `json:"avatarGT,omitempty"`
	AvatarGTE          *string  `json:"avatarGTE,omitempty"`
	AvatarLT           *string  `json:"avatarLT,omitempty"`
	AvatarLTE          *string  `json:"avatarLTE,omitempty"`
	AvatarContains     *string  `json:"avatarContains,omitempty"`
	AvatarHasPrefix    *string  `json:"avatarHasPrefix,omitempty"`
	AvatarHasSuffix    *string  `json:"avatarHasSuffix,omitempty"`
	AvatarIsNil        bool     `json:"avatarIsNil,omitempty"`
	AvatarNotNil       bool     `json:"avatarNotNil,omitempty"`
	AvatarEqualFold    *string  `json:"avatarEqualFold,omitempty"`
	AvatarContainsFold *string  `json:"avatarContainsFold,omitempty"`

	// "is_owner" field predicates.
	IsOwner    *bool `json:"isOwner,omitempty"`
	IsOwnerNEQ *bool `json:"isOwnerNEQ,omitempty"`

	// "requests" edge predicates.
	HasRequests     *bool                `json:"hasRequests,omitempty"`
	HasRequestsWith []*RequestWhereInput `json:"hasRequestsWith,omitempty"`

	// "api_keys" edge predicates.
	HasAPIKeys     *bool               `json:"hasAPIKeys,omitempty"`
	HasAPIKeysWith []*APIKeyWhereInput `json:"hasAPIKeysWith,omitempty"`

	// "roles" edge predicates.
	HasRoles     *bool             `json:"hasRoles,omitempty"`
	HasRolesWith []*RoleWhereInput `json:"hasRolesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.PreferLanguage != nil {
		predicates = append(predicates, user.PreferLanguageEQ(*i.PreferLanguage))
	}
	if i.PreferLanguageNEQ != nil {
		predicates = append(predicates, user.PreferLanguageNEQ(*i.PreferLanguageNEQ))
	}
	if len(i.PreferLanguageIn) > 0 {
		predicates = append(predicates, user.PreferLanguageIn(i.PreferLanguageIn...))
	}
	if len(i.PreferLanguageNotIn) > 0 {
		predicates = append(predicates, user.PreferLanguageNotIn(i.PreferLanguageNotIn...))
	}
	if i.PreferLanguageGT != nil {
		predicates = append(predicates, user.PreferLanguageGT(*i.PreferLanguageGT))
	}
	if i.PreferLanguageGTE != nil {
		predicates = append(predicates, user.PreferLanguageGTE(*i.PreferLanguageGTE))
	}
	if i.PreferLanguageLT != nil {
		predicates = append(predicates, user.PreferLanguageLT(*i.PreferLanguageLT))
	}
	if i.PreferLanguageLTE != nil {
		predicates = append(predicates, user.PreferLanguageLTE(*i.PreferLanguageLTE))
	}
	if i.PreferLanguageContains != nil {
		predicates = append(predicates, user.PreferLanguageContains(*i.PreferLanguageContains))
	}
	if i.PreferLanguageHasPrefix != nil {
		predicates = append(predicates, user.PreferLanguageHasPrefix(*i.PreferLanguageHasPrefix))
	}
	if i.PreferLanguageHasSuffix != nil {
		predicates = append(predicates, user.PreferLanguageHasSuffix(*i.PreferLanguageHasSuffix))
	}
	if i.PreferLanguageEqualFold != nil {
		predicates = append(predicates, user.PreferLanguageEqualFold(*i.PreferLanguageEqualFold))
	}
	if i.PreferLanguageContainsFold != nil {
		predicates = append(predicates, user.PreferLanguageContainsFold(*i.PreferLanguageContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Avatar != nil {
		predicates = append(predicates, user.AvatarEQ(*i.Avatar))
	}
	if i.AvatarNEQ != nil {
		predicates = append(predicates, user.AvatarNEQ(*i.AvatarNEQ))
	}
	if len(i.AvatarIn) > 0 {
		predicates = append(predicates, user.AvatarIn(i.AvatarIn...))
	}
	if len(i.AvatarNotIn) > 0 {
		predicates = append(predicates, user.AvatarNotIn(i.AvatarNotIn...))
	}
	if i.AvatarGT != nil {
		predicates = append(predicates, user.AvatarGT(*i.AvatarGT))
	}
	if i.AvatarGTE != nil {
		predicates = append(predicates, user.AvatarGTE(*i.AvatarGTE))
	}
	if i.AvatarLT != nil {
		predicates = append(predicates, user.AvatarLT(*i.AvatarLT))
	}
	if i.AvatarLTE != nil {
		predicates = append(predicates, user.AvatarLTE(*i.AvatarLTE))
	}
	if i.AvatarContains != nil {
		predicates = append(predicates, user.AvatarContains(*i.AvatarContains))
	}
	if i.AvatarHasPrefix != nil {
		predicates = append(predicates, user.AvatarHasPrefix(*i.AvatarHasPrefix))
	}
	if i.AvatarHasSuffix != nil {
		predicates = append(predicates, user.AvatarHasSuffix(*i.AvatarHasSuffix))
	}
	if i.AvatarIsNil {
		predicates = append(predicates, user.AvatarIsNil())
	}
	if i.AvatarNotNil {
		predicates = append(predicates, user.AvatarNotNil())
	}
	if i.AvatarEqualFold != nil {
		predicates = append(predicates, user.AvatarEqualFold(*i.AvatarEqualFold))
	}
	if i.AvatarContainsFold != nil {
		predicates = append(predicates, user.AvatarContainsFold(*i.AvatarContainsFold))
	}
	if i.IsOwner != nil {
		predicates = append(predicates, user.IsOwnerEQ(*i.IsOwner))
	}
	if i.IsOwnerNEQ != nil {
		predicates = append(predicates, user.IsOwnerNEQ(*i.IsOwnerNEQ))
	}

	if i.HasRequests != nil {
		p := user.HasRequests()
		if !*i.HasRequests {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestsWith) > 0 {
		with := make([]predicate.Request, 0, len(i.HasRequestsWith))
		for _, w := range i.HasRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRequestsWith(with...))
	}
	if i.HasAPIKeys != nil {
		p := user.HasAPIKeys()
		if !*i.HasAPIKeys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIKeysWith) > 0 {
		with := make([]predicate.APIKey, 0, len(i.HasAPIKeysWith))
		for _, w := range i.HasAPIKeysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIKeysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPIKeysWith(with...))
	}
	if i.HasRoles != nil {
		p := user.HasRoles()
		if !*i.HasRoles {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRolesWith) > 0 {
		with := make([]predicate.Role, 0, len(i.HasRolesWith))
		for _, w := range i.HasRolesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRolesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasRolesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
