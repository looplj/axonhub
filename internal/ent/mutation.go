// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/looplj/axonhub/internal/ent/apikey"
	"github.com/looplj/axonhub/internal/ent/channel"
	"github.com/looplj/axonhub/internal/ent/predicate"
	"github.com/looplj/axonhub/internal/ent/request"
	"github.com/looplj/axonhub/internal/ent/requestexecution"
	"github.com/looplj/axonhub/internal/ent/role"
	"github.com/looplj/axonhub/internal/ent/system"
	"github.com/looplj/axonhub/internal/ent/usagelog"
	"github.com/looplj/axonhub/internal/ent/user"
	"github.com/looplj/axonhub/internal/objects"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey           = "APIKey"
	TypeChannel          = "Channel"
	TypeRequest          = "Request"
	TypeRequestExecution = "RequestExecution"
	TypeRole             = "Role"
	TypeSystem           = "System"
	TypeUsageLog         = "UsageLog"
	TypeUser             = "User"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *int
	adddeleted_at   *int
	key             *string
	name            *string
	status          *apikey.Status
	scopes          *[]string
	appendscopes    []string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	requests        map[int]struct{}
	removedrequests map[int]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*APIKey, error)
	predicates      []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *APIKeyMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *APIKeyMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(a apikey.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r apikey.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v apikey.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// SetScopes sets the "scopes" field.
func (m *APIKeyMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *APIKeyMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *APIKeyMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *APIKeyMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *APIKeyMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[apikey.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *APIKeyMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[apikey.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *APIKeyMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, apikey.FieldScopes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *APIKeyMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *APIKeyMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *APIKeyMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *APIKeyMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *APIKeyMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *APIKeyMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *APIKeyMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	if m.scopes != nil {
		fields = append(fields, apikey.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldStatus:
		return m.Status()
	case apikey.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	case apikey.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(apikey.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apikey.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldScopes) {
		fields = append(fields, apikey.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	case apikey.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.requests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrequests != nil {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedrequests {
		edges = append(edges, apikey.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *int
	adddeleted_at          *int
	_type                  *channel.Type
	base_url               *string
	name                   *string
	status                 *channel.Status
	credentials            **objects.ChannelCredentials
	supported_models       *[]string
	appendsupported_models []string
	default_test_model     *string
	settings               **objects.ChannelSettings
	ordering_weight        *int
	addordering_weight     *int
	clearedFields          map[string]struct{}
	requests               map[int]struct{}
	removedrequests        map[int]struct{}
	clearedrequests        bool
	executions             map[int]struct{}
	removedexecutions      map[int]struct{}
	clearedexecutions      bool
	usage_logs             map[int]struct{}
	removedusage_logs      map[int]struct{}
	clearedusage_logs      bool
	done                   bool
	oldValue               func(context.Context) (*Channel, error)
	predicates             []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *ChannelMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *ChannelMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetType sets the "type" field.
func (m *ChannelMutation) SetType(c channel.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *ChannelMutation) GetType() (r channel.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldType(ctx context.Context) (v channel.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ChannelMutation) ResetType() {
	m._type = nil
}

// SetBaseURL sets the "base_url" field.
func (m *ChannelMutation) SetBaseURL(s string) {
	m.base_url = &s
}

// BaseURL returns the value of the "base_url" field in the mutation.
func (m *ChannelMutation) BaseURL() (r string, exists bool) {
	v := m.base_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseURL returns the old "base_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseURL: %w", err)
	}
	return oldValue.BaseURL, nil
}

// ClearBaseURL clears the value of the "base_url" field.
func (m *ChannelMutation) ClearBaseURL() {
	m.base_url = nil
	m.clearedFields[channel.FieldBaseURL] = struct{}{}
}

// BaseURLCleared returns if the "base_url" field was cleared in this mutation.
func (m *ChannelMutation) BaseURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldBaseURL]
	return ok
}

// ResetBaseURL resets all changes to the "base_url" field.
func (m *ChannelMutation) ResetBaseURL() {
	m.base_url = nil
	delete(m.clearedFields, channel.FieldBaseURL)
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(c channel.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r channel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v channel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetCredentials sets the "credentials" field.
func (m *ChannelMutation) SetCredentials(oc *objects.ChannelCredentials) {
	m.credentials = &oc
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *ChannelMutation) Credentials() (r *objects.ChannelCredentials, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCredentials(ctx context.Context) (v *objects.ChannelCredentials, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *ChannelMutation) ResetCredentials() {
	m.credentials = nil
}

// SetSupportedModels sets the "supported_models" field.
func (m *ChannelMutation) SetSupportedModels(s []string) {
	m.supported_models = &s
	m.appendsupported_models = nil
}

// SupportedModels returns the value of the "supported_models" field in the mutation.
func (m *ChannelMutation) SupportedModels() (r []string, exists bool) {
	v := m.supported_models
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedModels returns the old "supported_models" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSupportedModels(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedModels: %w", err)
	}
	return oldValue.SupportedModels, nil
}

// AppendSupportedModels adds s to the "supported_models" field.
func (m *ChannelMutation) AppendSupportedModels(s []string) {
	m.appendsupported_models = append(m.appendsupported_models, s...)
}

// AppendedSupportedModels returns the list of values that were appended to the "supported_models" field in this mutation.
func (m *ChannelMutation) AppendedSupportedModels() ([]string, bool) {
	if len(m.appendsupported_models) == 0 {
		return nil, false
	}
	return m.appendsupported_models, true
}

// ResetSupportedModels resets all changes to the "supported_models" field.
func (m *ChannelMutation) ResetSupportedModels() {
	m.supported_models = nil
	m.appendsupported_models = nil
}

// SetDefaultTestModel sets the "default_test_model" field.
func (m *ChannelMutation) SetDefaultTestModel(s string) {
	m.default_test_model = &s
}

// DefaultTestModel returns the value of the "default_test_model" field in the mutation.
func (m *ChannelMutation) DefaultTestModel() (r string, exists bool) {
	v := m.default_test_model
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultTestModel returns the old "default_test_model" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDefaultTestModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultTestModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultTestModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultTestModel: %w", err)
	}
	return oldValue.DefaultTestModel, nil
}

// ResetDefaultTestModel resets all changes to the "default_test_model" field.
func (m *ChannelMutation) ResetDefaultTestModel() {
	m.default_test_model = nil
}

// SetSettings sets the "settings" field.
func (m *ChannelMutation) SetSettings(os *objects.ChannelSettings) {
	m.settings = &os
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ChannelMutation) Settings() (r *objects.ChannelSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldSettings(ctx context.Context) (v *objects.ChannelSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *ChannelMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[channel.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *ChannelMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[channel.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *ChannelMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, channel.FieldSettings)
}

// SetOrderingWeight sets the "ordering_weight" field.
func (m *ChannelMutation) SetOrderingWeight(i int) {
	m.ordering_weight = &i
	m.addordering_weight = nil
}

// OrderingWeight returns the value of the "ordering_weight" field in the mutation.
func (m *ChannelMutation) OrderingWeight() (r int, exists bool) {
	v := m.ordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderingWeight returns the old "ordering_weight" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldOrderingWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderingWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderingWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderingWeight: %w", err)
	}
	return oldValue.OrderingWeight, nil
}

// AddOrderingWeight adds i to the "ordering_weight" field.
func (m *ChannelMutation) AddOrderingWeight(i int) {
	if m.addordering_weight != nil {
		*m.addordering_weight += i
	} else {
		m.addordering_weight = &i
	}
}

// AddedOrderingWeight returns the value that was added to the "ordering_weight" field in this mutation.
func (m *ChannelMutation) AddedOrderingWeight() (r int, exists bool) {
	v := m.addordering_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderingWeight resets all changes to the "ordering_weight" field.
func (m *ChannelMutation) ResetOrderingWeight() {
	m.ordering_weight = nil
	m.addordering_weight = nil
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ChannelMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ChannelMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ChannelMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ChannelMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ChannelMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ChannelMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ChannelMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *ChannelMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *ChannelMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *ChannelMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *ChannelMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *ChannelMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *ChannelMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *ChannelMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *ChannelMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *ChannelMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *ChannelMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *ChannelMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *ChannelMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m._type != nil {
		fields = append(fields, channel.FieldType)
	}
	if m.base_url != nil {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.credentials != nil {
		fields = append(fields, channel.FieldCredentials)
	}
	if m.supported_models != nil {
		fields = append(fields, channel.FieldSupportedModels)
	}
	if m.default_test_model != nil {
		fields = append(fields, channel.FieldDefaultTestModel)
	}
	if m.settings != nil {
		fields = append(fields, channel.FieldSettings)
	}
	if m.ordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldType:
		return m.GetType()
	case channel.FieldBaseURL:
		return m.BaseURL()
	case channel.FieldName:
		return m.Name()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldCredentials:
		return m.Credentials()
	case channel.FieldSupportedModels:
		return m.SupportedModels()
	case channel.FieldDefaultTestModel:
		return m.DefaultTestModel()
	case channel.FieldSettings:
		return m.Settings()
	case channel.FieldOrderingWeight:
		return m.OrderingWeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldType:
		return m.OldType(ctx)
	case channel.FieldBaseURL:
		return m.OldBaseURL(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldCredentials:
		return m.OldCredentials(ctx)
	case channel.FieldSupportedModels:
		return m.OldSupportedModels(ctx)
	case channel.FieldDefaultTestModel:
		return m.OldDefaultTestModel(ctx)
	case channel.FieldSettings:
		return m.OldSettings(ctx)
	case channel.FieldOrderingWeight:
		return m.OldOrderingWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldType:
		v, ok := value.(channel.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case channel.FieldBaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseURL(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(channel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldCredentials:
		v, ok := value.(*objects.ChannelCredentials)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case channel.FieldSupportedModels:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedModels(v)
		return nil
	case channel.FieldDefaultTestModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultTestModel(v)
		return nil
	case channel.FieldSettings:
		v, ok := value.(*objects.ChannelSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.addordering_weight != nil {
		fields = append(fields, channel.FieldOrderingWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldDeletedAt:
		return m.AddedDeletedAt()
	case channel.FieldOrderingWeight:
		return m.AddedOrderingWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case channel.FieldOrderingWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderingWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldBaseURL) {
		fields = append(fields, channel.FieldBaseURL)
	}
	if m.FieldCleared(channel.FieldSettings) {
		fields = append(fields, channel.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldBaseURL:
		m.ClearBaseURL()
		return nil
	case channel.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldType:
		m.ResetType()
		return nil
	case channel.FieldBaseURL:
		m.ResetBaseURL()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldCredentials:
		m.ResetCredentials()
		return nil
	case channel.FieldSupportedModels:
		m.ResetSupportedModels()
		return nil
	case channel.FieldDefaultTestModel:
		m.ResetDefaultTestModel()
		return nil
	case channel.FieldSettings:
		m.ResetSettings()
		return nil
	case channel.FieldOrderingWeight:
		m.ResetOrderingWeight()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.requests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.executions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.usage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrequests != nil {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.removedexecutions != nil {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrequests {
		edges = append(edges, channel.EdgeRequests)
	}
	if m.clearedexecutions {
		edges = append(edges, channel.EdgeExecutions)
	}
	if m.clearedusage_logs {
		edges = append(edges, channel.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeRequests:
		return m.clearedrequests
	case channel.EdgeExecutions:
		return m.clearedexecutions
	case channel.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeRequests:
		m.ResetRequests()
		return nil
	case channel.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case channel.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *int
	adddeleted_at         *int
	source                *request.Source
	model_id              *string
	format                *string
	request_body          *objects.JSONRawMessage
	appendrequest_body    objects.JSONRawMessage
	response_body         *objects.JSONRawMessage
	appendresponse_body   objects.JSONRawMessage
	response_chunks       *[]objects.JSONRawMessage
	appendresponse_chunks []objects.JSONRawMessage
	external_id           *string
	status                *request.Status
	clearedFields         map[string]struct{}
	user                  *int
	cleareduser           bool
	api_key               *int
	clearedapi_key        bool
	executions            map[int]struct{}
	removedexecutions     map[int]struct{}
	clearedexecutions     bool
	channel               *int
	clearedchannel        bool
	usage_logs            map[int]struct{}
	removedusage_logs     map[int]struct{}
	clearedusage_logs     bool
	done                  bool
	oldValue              func(context.Context) (*Request, error)
	predicates            []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id int) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RequestMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RequestMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RequestMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RequestMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RequestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RequestMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RequestMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RequestMutation) ResetUserID() {
	m.user = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *RequestMutation) SetAPIKeyID(i int) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *RequestMutation) APIKeyID() (r int, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldAPIKeyID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ClearAPIKeyID clears the value of the "api_key_id" field.
func (m *RequestMutation) ClearAPIKeyID() {
	m.api_key = nil
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyIDCleared returns if the "api_key_id" field was cleared in this mutation.
func (m *RequestMutation) APIKeyIDCleared() bool {
	_, ok := m.clearedFields[request.FieldAPIKeyID]
	return ok
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *RequestMutation) ResetAPIKeyID() {
	m.api_key = nil
	delete(m.clearedFields, request.FieldAPIKeyID)
}

// SetSource sets the "source" field.
func (m *RequestMutation) SetSource(r request.Source) {
	m.source = &r
}

// Source returns the value of the "source" field in the mutation.
func (m *RequestMutation) Source() (r request.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldSource(ctx context.Context) (v request.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RequestMutation) ResetSource() {
	m.source = nil
}

// SetModelID sets the "model_id" field.
func (m *RequestMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[request.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, request.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[request.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[request.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, request.FieldResponseChunks)
}

// SetChannelID sets the "channel_id" field.
func (m *RequestMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *RequestMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *RequestMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[request.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, request.FieldChannelID)
}

// SetExternalID sets the "external_id" field.
func (m *RequestMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[request.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[request.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, request.FieldExternalID)
}

// SetStatus sets the "status" field.
func (m *RequestMutation) SetStatus(r request.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestMutation) Status() (r request.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldStatus(ctx context.Context) (v request.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestMutation) ResetStatus() {
	m.status = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RequestMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[request.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RequestMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RequestMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *RequestMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[request.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *RequestMutation) APIKeyCleared() bool {
	return m.APIKeyIDCleared() || m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) APIKeyIDs() (ids []int) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *RequestMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// AddExecutionIDs adds the "executions" edge to the RequestExecution entity by ids.
func (m *RequestMutation) AddExecutionIDs(ids ...int) {
	if m.executions == nil {
		m.executions = make(map[int]struct{})
	}
	for i := range ids {
		m.executions[ids[i]] = struct{}{}
	}
}

// ClearExecutions clears the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) ClearExecutions() {
	m.clearedexecutions = true
}

// ExecutionsCleared reports if the "executions" edge to the RequestExecution entity was cleared.
func (m *RequestMutation) ExecutionsCleared() bool {
	return m.clearedexecutions
}

// RemoveExecutionIDs removes the "executions" edge to the RequestExecution entity by IDs.
func (m *RequestMutation) RemoveExecutionIDs(ids ...int) {
	if m.removedexecutions == nil {
		m.removedexecutions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.executions, ids[i])
		m.removedexecutions[ids[i]] = struct{}{}
	}
}

// RemovedExecutions returns the removed IDs of the "executions" edge to the RequestExecution entity.
func (m *RequestMutation) RemovedExecutionsIDs() (ids []int) {
	for id := range m.removedexecutions {
		ids = append(ids, id)
	}
	return
}

// ExecutionsIDs returns the "executions" edge IDs in the mutation.
func (m *RequestMutation) ExecutionsIDs() (ids []int) {
	for id := range m.executions {
		ids = append(ids, id)
	}
	return
}

// ResetExecutions resets all changes to the "executions" edge.
func (m *RequestMutation) ResetExecutions() {
	m.executions = nil
	m.clearedexecutions = false
	m.removedexecutions = nil
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[request.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *RequestMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *RequestMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *RequestMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *RequestMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *RequestMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *RequestMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, request.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, request.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, request.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, request.FieldUserID)
	}
	if m.api_key != nil {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.source != nil {
		fields = append(fields, request.FieldSource)
	}
	if m.model_id != nil {
		fields = append(fields, request.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, request.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, request.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.channel != nil {
		fields = append(fields, request.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, request.FieldExternalID)
	}
	if m.status != nil {
		fields = append(fields, request.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldCreatedAt:
		return m.CreatedAt()
	case request.FieldUpdatedAt:
		return m.UpdatedAt()
	case request.FieldDeletedAt:
		return m.DeletedAt()
	case request.FieldUserID:
		return m.UserID()
	case request.FieldAPIKeyID:
		return m.APIKeyID()
	case request.FieldSource:
		return m.Source()
	case request.FieldModelID:
		return m.ModelID()
	case request.FieldFormat:
		return m.Format()
	case request.FieldRequestBody:
		return m.RequestBody()
	case request.FieldResponseBody:
		return m.ResponseBody()
	case request.FieldResponseChunks:
		return m.ResponseChunks()
	case request.FieldChannelID:
		return m.ChannelID()
	case request.FieldExternalID:
		return m.ExternalID()
	case request.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case request.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case request.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case request.FieldUserID:
		return m.OldUserID(ctx)
	case request.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case request.FieldSource:
		return m.OldSource(ctx)
	case request.FieldModelID:
		return m.OldModelID(ctx)
	case request.FieldFormat:
		return m.OldFormat(ctx)
	case request.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case request.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case request.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case request.FieldChannelID:
		return m.OldChannelID(ctx)
	case request.FieldExternalID:
		return m.OldExternalID(ctx)
	case request.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case request.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case request.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case request.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case request.FieldAPIKeyID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case request.FieldSource:
		v, ok := value.(request.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case request.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case request.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case request.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case request.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case request.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case request.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case request.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case request.FieldStatus:
		v, ok := value.(request.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, request.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case request.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case request.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldAPIKeyID) {
		fields = append(fields, request.FieldAPIKeyID)
	}
	if m.FieldCleared(request.FieldResponseBody) {
		fields = append(fields, request.FieldResponseBody)
	}
	if m.FieldCleared(request.FieldResponseChunks) {
		fields = append(fields, request.FieldResponseChunks)
	}
	if m.FieldCleared(request.FieldChannelID) {
		fields = append(fields, request.FieldChannelID)
	}
	if m.FieldCleared(request.FieldExternalID) {
		fields = append(fields, request.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldAPIKeyID:
		m.ClearAPIKeyID()
		return nil
	case request.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ClearChannelID()
		return nil
	case request.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case request.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case request.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case request.FieldUserID:
		m.ResetUserID()
		return nil
	case request.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case request.FieldSource:
		m.ResetSource()
		return nil
	case request.FieldModelID:
		m.ResetModelID()
		return nil
	case request.FieldFormat:
		m.ResetFormat()
		return nil
	case request.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case request.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case request.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case request.FieldChannelID:
		m.ResetChannelID()
		return nil
	case request.FieldExternalID:
		m.ResetExternalID()
		return nil
	case request.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, request.EdgeUser)
	}
	if m.api_key != nil {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.executions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.channel != nil {
		edges = append(edges, request.EdgeChannel)
	}
	if m.usage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.executions))
		for id := range m.executions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedexecutions != nil {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeExecutions:
		ids := make([]ent.Value, 0, len(m.removedexecutions))
		for id := range m.removedexecutions {
			ids = append(ids, id)
		}
		return ids
	case request.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, request.EdgeUser)
	}
	if m.clearedapi_key {
		edges = append(edges, request.EdgeAPIKey)
	}
	if m.clearedexecutions {
		edges = append(edges, request.EdgeExecutions)
	}
	if m.clearedchannel {
		edges = append(edges, request.EdgeChannel)
	}
	if m.clearedusage_logs {
		edges = append(edges, request.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeUser:
		return m.cleareduser
	case request.EdgeAPIKey:
		return m.clearedapi_key
	case request.EdgeExecutions:
		return m.clearedexecutions
	case request.EdgeChannel:
		return m.clearedchannel
	case request.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeUser:
		m.ClearUser()
		return nil
	case request.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case request.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeUser:
		m.ResetUser()
		return nil
	case request.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case request.EdgeExecutions:
		m.ResetExecutions()
		return nil
	case request.EdgeChannel:
		m.ResetChannel()
		return nil
	case request.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// RequestExecutionMutation represents an operation that mutates the RequestExecution nodes in the graph.
type RequestExecutionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	created_at            *time.Time
	updated_at            *time.Time
	user_id               *int
	adduser_id            *int
	external_id           *string
	model_id              *string
	format                *string
	request_body          *objects.JSONRawMessage
	appendrequest_body    objects.JSONRawMessage
	response_body         *objects.JSONRawMessage
	appendresponse_body   objects.JSONRawMessage
	response_chunks       *[]objects.JSONRawMessage
	appendresponse_chunks []objects.JSONRawMessage
	error_message         *string
	status                *requestexecution.Status
	clearedFields         map[string]struct{}
	request               *int
	clearedrequest        bool
	channel               *int
	clearedchannel        bool
	done                  bool
	oldValue              func(context.Context) (*RequestExecution, error)
	predicates            []predicate.RequestExecution
}

var _ ent.Mutation = (*RequestExecutionMutation)(nil)

// requestexecutionOption allows management of the mutation configuration using functional options.
type requestexecutionOption func(*RequestExecutionMutation)

// newRequestExecutionMutation creates new mutation for the RequestExecution entity.
func newRequestExecutionMutation(c config, op Op, opts ...requestexecutionOption) *RequestExecutionMutation {
	m := &RequestExecutionMutation{
		config:        c,
		op:            op,
		typ:           TypeRequestExecution,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestExecutionID sets the ID field of the mutation.
func withRequestExecutionID(id int) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		var (
			err   error
			once  sync.Once
			value *RequestExecution
		)
		m.oldValue = func(ctx context.Context) (*RequestExecution, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RequestExecution.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequestExecution sets the old RequestExecution of the mutation.
func withRequestExecution(node *RequestExecution) requestexecutionOption {
	return func(m *RequestExecutionMutation) {
		m.oldValue = func(context.Context) (*RequestExecution, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestExecutionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestExecutionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestExecutionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestExecutionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RequestExecution.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RequestExecutionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RequestExecutionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RequestExecutionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RequestExecutionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RequestExecutionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RequestExecutionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RequestExecutionMutation) SetUserID(i int) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RequestExecutionMutation) UserID() (r int, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *RequestExecutionMutation) AddUserID(i int) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *RequestExecutionMutation) AddedUserID() (r int, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RequestExecutionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRequestID sets the "request_id" field.
func (m *RequestExecutionMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *RequestExecutionMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *RequestExecutionMutation) ResetRequestID() {
	m.request = nil
}

// SetChannelID sets the "channel_id" field.
func (m *RequestExecutionMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *RequestExecutionMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *RequestExecutionMutation) ResetChannelID() {
	m.channel = nil
}

// SetExternalID sets the "external_id" field.
func (m *RequestExecutionMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *RequestExecutionMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *RequestExecutionMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[requestexecution.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *RequestExecutionMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *RequestExecutionMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, requestexecution.FieldExternalID)
}

// SetModelID sets the "model_id" field.
func (m *RequestExecutionMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *RequestExecutionMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *RequestExecutionMutation) ResetModelID() {
	m.model_id = nil
}

// SetFormat sets the "format" field.
func (m *RequestExecutionMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *RequestExecutionMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *RequestExecutionMutation) ResetFormat() {
	m.format = nil
}

// SetRequestBody sets the "request_body" field.
func (m *RequestExecutionMutation) SetRequestBody(orm objects.JSONRawMessage) {
	m.request_body = &orm
	m.appendrequest_body = nil
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *RequestExecutionMutation) RequestBody() (r objects.JSONRawMessage, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldRequestBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// AppendRequestBody adds orm to the "request_body" field.
func (m *RequestExecutionMutation) AppendRequestBody(orm objects.JSONRawMessage) {
	m.appendrequest_body = append(m.appendrequest_body, orm...)
}

// AppendedRequestBody returns the list of values that were appended to the "request_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedRequestBody() (objects.JSONRawMessage, bool) {
	if len(m.appendrequest_body) == 0 {
		return nil, false
	}
	return m.appendrequest_body, true
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *RequestExecutionMutation) ResetRequestBody() {
	m.request_body = nil
	m.appendrequest_body = nil
}

// SetResponseBody sets the "response_body" field.
func (m *RequestExecutionMutation) SetResponseBody(orm objects.JSONRawMessage) {
	m.response_body = &orm
	m.appendresponse_body = nil
}

// ResponseBody returns the value of the "response_body" field in the mutation.
func (m *RequestExecutionMutation) ResponseBody() (r objects.JSONRawMessage, exists bool) {
	v := m.response_body
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseBody returns the old "response_body" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseBody(ctx context.Context) (v objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseBody: %w", err)
	}
	return oldValue.ResponseBody, nil
}

// AppendResponseBody adds orm to the "response_body" field.
func (m *RequestExecutionMutation) AppendResponseBody(orm objects.JSONRawMessage) {
	m.appendresponse_body = append(m.appendresponse_body, orm...)
}

// AppendedResponseBody returns the list of values that were appended to the "response_body" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseBody() (objects.JSONRawMessage, bool) {
	if len(m.appendresponse_body) == 0 {
		return nil, false
	}
	return m.appendresponse_body, true
}

// ClearResponseBody clears the value of the "response_body" field.
func (m *RequestExecutionMutation) ClearResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	m.clearedFields[requestexecution.FieldResponseBody] = struct{}{}
}

// ResponseBodyCleared returns if the "response_body" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseBodyCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseBody]
	return ok
}

// ResetResponseBody resets all changes to the "response_body" field.
func (m *RequestExecutionMutation) ResetResponseBody() {
	m.response_body = nil
	m.appendresponse_body = nil
	delete(m.clearedFields, requestexecution.FieldResponseBody)
}

// SetResponseChunks sets the "response_chunks" field.
func (m *RequestExecutionMutation) SetResponseChunks(orm []objects.JSONRawMessage) {
	m.response_chunks = &orm
	m.appendresponse_chunks = nil
}

// ResponseChunks returns the value of the "response_chunks" field in the mutation.
func (m *RequestExecutionMutation) ResponseChunks() (r []objects.JSONRawMessage, exists bool) {
	v := m.response_chunks
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseChunks returns the old "response_chunks" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldResponseChunks(ctx context.Context) (v []objects.JSONRawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseChunks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseChunks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseChunks: %w", err)
	}
	return oldValue.ResponseChunks, nil
}

// AppendResponseChunks adds orm to the "response_chunks" field.
func (m *RequestExecutionMutation) AppendResponseChunks(orm []objects.JSONRawMessage) {
	m.appendresponse_chunks = append(m.appendresponse_chunks, orm...)
}

// AppendedResponseChunks returns the list of values that were appended to the "response_chunks" field in this mutation.
func (m *RequestExecutionMutation) AppendedResponseChunks() ([]objects.JSONRawMessage, bool) {
	if len(m.appendresponse_chunks) == 0 {
		return nil, false
	}
	return m.appendresponse_chunks, true
}

// ClearResponseChunks clears the value of the "response_chunks" field.
func (m *RequestExecutionMutation) ClearResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	m.clearedFields[requestexecution.FieldResponseChunks] = struct{}{}
}

// ResponseChunksCleared returns if the "response_chunks" field was cleared in this mutation.
func (m *RequestExecutionMutation) ResponseChunksCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldResponseChunks]
	return ok
}

// ResetResponseChunks resets all changes to the "response_chunks" field.
func (m *RequestExecutionMutation) ResetResponseChunks() {
	m.response_chunks = nil
	m.appendresponse_chunks = nil
	delete(m.clearedFields, requestexecution.FieldResponseChunks)
}

// SetErrorMessage sets the "error_message" field.
func (m *RequestExecutionMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *RequestExecutionMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *RequestExecutionMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[requestexecution.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *RequestExecutionMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[requestexecution.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *RequestExecutionMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, requestexecution.FieldErrorMessage)
}

// SetStatus sets the "status" field.
func (m *RequestExecutionMutation) SetStatus(r requestexecution.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RequestExecutionMutation) Status() (r requestexecution.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RequestExecution entity.
// If the RequestExecution object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestExecutionMutation) OldStatus(ctx context.Context) (v requestexecution.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RequestExecutionMutation) ResetStatus() {
	m.status = nil
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *RequestExecutionMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[requestexecution.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *RequestExecutionMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *RequestExecutionMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *RequestExecutionMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[requestexecution.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *RequestExecutionMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *RequestExecutionMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *RequestExecutionMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the RequestExecutionMutation builder.
func (m *RequestExecutionMutation) Where(ps ...predicate.RequestExecution) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestExecutionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestExecutionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RequestExecution, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestExecutionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestExecutionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RequestExecution).
func (m *RequestExecutionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestExecutionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, requestexecution.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, requestexecution.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, requestexecution.FieldUserID)
	}
	if m.request != nil {
		fields = append(fields, requestexecution.FieldRequestID)
	}
	if m.channel != nil {
		fields = append(fields, requestexecution.FieldChannelID)
	}
	if m.external_id != nil {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.model_id != nil {
		fields = append(fields, requestexecution.FieldModelID)
	}
	if m.format != nil {
		fields = append(fields, requestexecution.FieldFormat)
	}
	if m.request_body != nil {
		fields = append(fields, requestexecution.FieldRequestBody)
	}
	if m.response_body != nil {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.response_chunks != nil {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.error_message != nil {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	if m.status != nil {
		fields = append(fields, requestexecution.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestExecutionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.CreatedAt()
	case requestexecution.FieldUpdatedAt:
		return m.UpdatedAt()
	case requestexecution.FieldUserID:
		return m.UserID()
	case requestexecution.FieldRequestID:
		return m.RequestID()
	case requestexecution.FieldChannelID:
		return m.ChannelID()
	case requestexecution.FieldExternalID:
		return m.ExternalID()
	case requestexecution.FieldModelID:
		return m.ModelID()
	case requestexecution.FieldFormat:
		return m.Format()
	case requestexecution.FieldRequestBody:
		return m.RequestBody()
	case requestexecution.FieldResponseBody:
		return m.ResponseBody()
	case requestexecution.FieldResponseChunks:
		return m.ResponseChunks()
	case requestexecution.FieldErrorMessage:
		return m.ErrorMessage()
	case requestexecution.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestExecutionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case requestexecution.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case requestexecution.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case requestexecution.FieldUserID:
		return m.OldUserID(ctx)
	case requestexecution.FieldRequestID:
		return m.OldRequestID(ctx)
	case requestexecution.FieldChannelID:
		return m.OldChannelID(ctx)
	case requestexecution.FieldExternalID:
		return m.OldExternalID(ctx)
	case requestexecution.FieldModelID:
		return m.OldModelID(ctx)
	case requestexecution.FieldFormat:
		return m.OldFormat(ctx)
	case requestexecution.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case requestexecution.FieldResponseBody:
		return m.OldResponseBody(ctx)
	case requestexecution.FieldResponseChunks:
		return m.OldResponseChunks(ctx)
	case requestexecution.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case requestexecution.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown RequestExecution field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case requestexecution.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case requestexecution.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case requestexecution.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case requestexecution.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case requestexecution.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case requestexecution.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case requestexecution.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	case requestexecution.FieldRequestBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case requestexecution.FieldResponseBody:
		v, ok := value.(objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseBody(v)
		return nil
	case requestexecution.FieldResponseChunks:
		v, ok := value.([]objects.JSONRawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseChunks(v)
		return nil
	case requestexecution.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case requestexecution.FieldStatus:
		v, ok := value.(requestexecution.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestExecutionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, requestexecution.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestExecutionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case requestexecution.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestExecutionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case requestexecution.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown RequestExecution numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestExecutionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(requestexecution.FieldExternalID) {
		fields = append(fields, requestexecution.FieldExternalID)
	}
	if m.FieldCleared(requestexecution.FieldResponseBody) {
		fields = append(fields, requestexecution.FieldResponseBody)
	}
	if m.FieldCleared(requestexecution.FieldResponseChunks) {
		fields = append(fields, requestexecution.FieldResponseChunks)
	}
	if m.FieldCleared(requestexecution.FieldErrorMessage) {
		fields = append(fields, requestexecution.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestExecutionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ClearField(name string) error {
	switch name {
	case requestexecution.FieldExternalID:
		m.ClearExternalID()
		return nil
	case requestexecution.FieldResponseBody:
		m.ClearResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ClearResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestExecutionMutation) ResetField(name string) error {
	switch name {
	case requestexecution.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case requestexecution.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case requestexecution.FieldUserID:
		m.ResetUserID()
		return nil
	case requestexecution.FieldRequestID:
		m.ResetRequestID()
		return nil
	case requestexecution.FieldChannelID:
		m.ResetChannelID()
		return nil
	case requestexecution.FieldExternalID:
		m.ResetExternalID()
		return nil
	case requestexecution.FieldModelID:
		m.ResetModelID()
		return nil
	case requestexecution.FieldFormat:
		m.ResetFormat()
		return nil
	case requestexecution.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case requestexecution.FieldResponseBody:
		m.ResetResponseBody()
		return nil
	case requestexecution.FieldResponseChunks:
		m.ResetResponseChunks()
		return nil
	case requestexecution.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case requestexecution.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestExecutionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.request != nil {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.channel != nil {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestExecutionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case requestexecution.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case requestexecution.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestExecutionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestExecutionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestExecutionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrequest {
		edges = append(edges, requestexecution.EdgeRequest)
	}
	if m.clearedchannel {
		edges = append(edges, requestexecution.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestExecutionMutation) EdgeCleared(name string) bool {
	switch name {
	case requestexecution.EdgeRequest:
		return m.clearedrequest
	case requestexecution.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestExecutionMutation) ClearEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ClearRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestExecutionMutation) ResetEdge(name string) error {
	switch name {
	case requestexecution.EdgeRequest:
		m.ResetRequest()
		return nil
	case requestexecution.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown RequestExecution edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	code          *string
	name          *string
	scopes        *[]string
	appendscopes  []string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *RoleMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *RoleMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetScopes sets the "scopes" field.
func (m *RoleMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RoleMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RoleMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RoleMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *RoleMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[role.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *RoleMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[role.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RoleMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, role.FieldScopes)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.scopes != nil {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldCode:
		return m.Code()
	case role.FieldName:
		return m.Name()
	case role.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldScopes) {
		fields = append(fields, role.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SystemMutation represents an operation that mutates the System nodes in the graph.
type SystemMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *int
	adddeleted_at *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*System, error)
	predicates    []predicate.System
}

var _ ent.Mutation = (*SystemMutation)(nil)

// systemOption allows management of the mutation configuration using functional options.
type systemOption func(*SystemMutation)

// newSystemMutation creates new mutation for the System entity.
func newSystemMutation(c config, op Op, opts ...systemOption) *SystemMutation {
	m := &SystemMutation{
		config:        c,
		op:            op,
		typ:           TypeSystem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemID sets the ID field of the mutation.
func withSystemID(id int) systemOption {
	return func(m *SystemMutation) {
		var (
			err   error
			once  sync.Once
			value *System
		)
		m.oldValue = func(ctx context.Context) (*System, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().System.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystem sets the old System of the mutation.
func withSystem(node *System) systemOption {
	return func(m *SystemMutation) {
		m.oldValue = func(context.Context) (*System, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().System.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SystemMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SystemMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *SystemMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *SystemMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SystemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetKey sets the "key" field.
func (m *SystemMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SystemMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SystemMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SystemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SystemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the System entity.
// If the System object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SystemMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SystemMutation builder.
func (m *SystemMutation) Where(ps ...predicate.System) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.System, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (System).
func (m *SystemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, system.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, system.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, system.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, system.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case system.FieldCreatedAt:
		return m.CreatedAt()
	case system.FieldUpdatedAt:
		return m.UpdatedAt()
	case system.FieldDeletedAt:
		return m.DeletedAt()
	case system.FieldKey:
		return m.Key()
	case system.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case system.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case system.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case system.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case system.FieldKey:
		return m.OldKey(ctx)
	case system.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown System field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case system.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case system.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case system.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case system.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, system.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case system.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case system.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown System numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown System nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemMutation) ResetField(name string) error {
	switch name {
	case system.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case system.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case system.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case system.FieldKey:
		m.ResetKey()
		return nil
	case system.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown System field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown System unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown System edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	created_at                               *time.Time
	updated_at                               *time.Time
	deleted_at                               *int
	adddeleted_at                            *int
	model_id                                 *string
	prompt_tokens                            *int
	addprompt_tokens                         *int
	completion_tokens                        *int
	addcompletion_tokens                     *int
	total_tokens                             *int
	addtotal_tokens                          *int
	prompt_audio_tokens                      *int
	addprompt_audio_tokens                   *int
	prompt_cached_tokens                     *int
	addprompt_cached_tokens                  *int
	completion_audio_tokens                  *int
	addcompletion_audio_tokens               *int
	completion_reasoning_tokens              *int
	addcompletion_reasoning_tokens           *int
	completion_accepted_prediction_tokens    *int
	addcompletion_accepted_prediction_tokens *int
	completion_rejected_prediction_tokens    *int
	addcompletion_rejected_prediction_tokens *int
	source                                   *usagelog.Source
	format                                   *string
	clearedFields                            map[string]struct{}
	user                                     *int
	cleareduser                              bool
	request                                  *int
	clearedrequest                           bool
	channel                                  *int
	clearedchannel                           bool
	done                                     bool
	oldValue                                 func(context.Context) (*UsageLog, error)
	predicates                               []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UsageLogMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UsageLogMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UsageLogMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UsageLogMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UsageLogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UsageLogMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageLogMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageLogMutation) ResetUserID() {
	m.user = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(i int) {
	m.request = &i
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r int, exists bool) {
	v := m.request
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request = nil
}

// SetChannelID sets the "channel_id" field.
func (m *UsageLogMutation) SetChannelID(i int) {
	m.channel = &i
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *UsageLogMutation) ChannelID() (r int, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldChannelID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ClearChannelID clears the value of the "channel_id" field.
func (m *UsageLogMutation) ClearChannelID() {
	m.channel = nil
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelIDCleared returns if the "channel_id" field was cleared in this mutation.
func (m *UsageLogMutation) ChannelIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldChannelID]
	return ok
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *UsageLogMutation) ResetChannelID() {
	m.channel = nil
	delete(m.clearedFields, usagelog.FieldChannelID)
}

// SetModelID sets the "model_id" field.
func (m *UsageLogMutation) SetModelID(s string) {
	m.model_id = &s
}

// ModelID returns the value of the "model_id" field in the mutation.
func (m *UsageLogMutation) ModelID() (r string, exists bool) {
	v := m.model_id
	if v == nil {
		return
	}
	return *v, true
}

// OldModelID returns the old "model_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelID: %w", err)
	}
	return oldValue.ModelID, nil
}

// ResetModelID resets all changes to the "model_id" field.
func (m *UsageLogMutation) ResetModelID() {
	m.model_id = nil
}

// SetPromptTokens sets the "prompt_tokens" field.
func (m *UsageLogMutation) SetPromptTokens(i int) {
	m.prompt_tokens = &i
	m.addprompt_tokens = nil
}

// PromptTokens returns the value of the "prompt_tokens" field in the mutation.
func (m *UsageLogMutation) PromptTokens() (r int, exists bool) {
	v := m.prompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptTokens returns the old "prompt_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptTokens: %w", err)
	}
	return oldValue.PromptTokens, nil
}

// AddPromptTokens adds i to the "prompt_tokens" field.
func (m *UsageLogMutation) AddPromptTokens(i int) {
	if m.addprompt_tokens != nil {
		*m.addprompt_tokens += i
	} else {
		m.addprompt_tokens = &i
	}
}

// AddedPromptTokens returns the value that was added to the "prompt_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptTokens() (r int, exists bool) {
	v := m.addprompt_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetPromptTokens resets all changes to the "prompt_tokens" field.
func (m *UsageLogMutation) ResetPromptTokens() {
	m.prompt_tokens = nil
	m.addprompt_tokens = nil
}

// SetCompletionTokens sets the "completion_tokens" field.
func (m *UsageLogMutation) SetCompletionTokens(i int) {
	m.completion_tokens = &i
	m.addcompletion_tokens = nil
}

// CompletionTokens returns the value of the "completion_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionTokens() (r int, exists bool) {
	v := m.completion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTokens returns the old "completion_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTokens: %w", err)
	}
	return oldValue.CompletionTokens, nil
}

// AddCompletionTokens adds i to the "completion_tokens" field.
func (m *UsageLogMutation) AddCompletionTokens(i int) {
	if m.addcompletion_tokens != nil {
		*m.addcompletion_tokens += i
	} else {
		m.addcompletion_tokens = &i
	}
}

// AddedCompletionTokens returns the value that was added to the "completion_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionTokens() (r int, exists bool) {
	v := m.addcompletion_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompletionTokens resets all changes to the "completion_tokens" field.
func (m *UsageLogMutation) ResetCompletionTokens() {
	m.completion_tokens = nil
	m.addcompletion_tokens = nil
}

// SetTotalTokens sets the "total_tokens" field.
func (m *UsageLogMutation) SetTotalTokens(i int) {
	m.total_tokens = &i
	m.addtotal_tokens = nil
}

// TotalTokens returns the value of the "total_tokens" field in the mutation.
func (m *UsageLogMutation) TotalTokens() (r int, exists bool) {
	v := m.total_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokens returns the old "total_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokens: %w", err)
	}
	return oldValue.TotalTokens, nil
}

// AddTotalTokens adds i to the "total_tokens" field.
func (m *UsageLogMutation) AddTotalTokens(i int) {
	if m.addtotal_tokens != nil {
		*m.addtotal_tokens += i
	} else {
		m.addtotal_tokens = &i
	}
}

// AddedTotalTokens returns the value that was added to the "total_tokens" field in this mutation.
func (m *UsageLogMutation) AddedTotalTokens() (r int, exists bool) {
	v := m.addtotal_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTokens resets all changes to the "total_tokens" field.
func (m *UsageLogMutation) ResetTotalTokens() {
	m.total_tokens = nil
	m.addtotal_tokens = nil
}

// SetPromptAudioTokens sets the "prompt_audio_tokens" field.
func (m *UsageLogMutation) SetPromptAudioTokens(i int) {
	m.prompt_audio_tokens = &i
	m.addprompt_audio_tokens = nil
}

// PromptAudioTokens returns the value of the "prompt_audio_tokens" field in the mutation.
func (m *UsageLogMutation) PromptAudioTokens() (r int, exists bool) {
	v := m.prompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptAudioTokens returns the old "prompt_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptAudioTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptAudioTokens: %w", err)
	}
	return oldValue.PromptAudioTokens, nil
}

// AddPromptAudioTokens adds i to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) AddPromptAudioTokens(i int) {
	if m.addprompt_audio_tokens != nil {
		*m.addprompt_audio_tokens += i
	} else {
		m.addprompt_audio_tokens = &i
	}
}

// AddedPromptAudioTokens returns the value that was added to the "prompt_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptAudioTokens() (r int, exists bool) {
	v := m.addprompt_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptAudioTokens clears the value of the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ClearPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	m.clearedFields[usagelog.FieldPromptAudioTokens] = struct{}{}
}

// PromptAudioTokensCleared returns if the "prompt_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptAudioTokens]
	return ok
}

// ResetPromptAudioTokens resets all changes to the "prompt_audio_tokens" field.
func (m *UsageLogMutation) ResetPromptAudioTokens() {
	m.prompt_audio_tokens = nil
	m.addprompt_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptAudioTokens)
}

// SetPromptCachedTokens sets the "prompt_cached_tokens" field.
func (m *UsageLogMutation) SetPromptCachedTokens(i int) {
	m.prompt_cached_tokens = &i
	m.addprompt_cached_tokens = nil
}

// PromptCachedTokens returns the value of the "prompt_cached_tokens" field in the mutation.
func (m *UsageLogMutation) PromptCachedTokens() (r int, exists bool) {
	v := m.prompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptCachedTokens returns the old "prompt_cached_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldPromptCachedTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptCachedTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptCachedTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptCachedTokens: %w", err)
	}
	return oldValue.PromptCachedTokens, nil
}

// AddPromptCachedTokens adds i to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) AddPromptCachedTokens(i int) {
	if m.addprompt_cached_tokens != nil {
		*m.addprompt_cached_tokens += i
	} else {
		m.addprompt_cached_tokens = &i
	}
}

// AddedPromptCachedTokens returns the value that was added to the "prompt_cached_tokens" field in this mutation.
func (m *UsageLogMutation) AddedPromptCachedTokens() (r int, exists bool) {
	v := m.addprompt_cached_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearPromptCachedTokens clears the value of the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ClearPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	m.clearedFields[usagelog.FieldPromptCachedTokens] = struct{}{}
}

// PromptCachedTokensCleared returns if the "prompt_cached_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) PromptCachedTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldPromptCachedTokens]
	return ok
}

// ResetPromptCachedTokens resets all changes to the "prompt_cached_tokens" field.
func (m *UsageLogMutation) ResetPromptCachedTokens() {
	m.prompt_cached_tokens = nil
	m.addprompt_cached_tokens = nil
	delete(m.clearedFields, usagelog.FieldPromptCachedTokens)
}

// SetCompletionAudioTokens sets the "completion_audio_tokens" field.
func (m *UsageLogMutation) SetCompletionAudioTokens(i int) {
	m.completion_audio_tokens = &i
	m.addcompletion_audio_tokens = nil
}

// CompletionAudioTokens returns the value of the "completion_audio_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAudioTokens() (r int, exists bool) {
	v := m.completion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAudioTokens returns the old "completion_audio_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAudioTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAudioTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAudioTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAudioTokens: %w", err)
	}
	return oldValue.CompletionAudioTokens, nil
}

// AddCompletionAudioTokens adds i to the "completion_audio_tokens" field.
func (m *UsageLogMutation) AddCompletionAudioTokens(i int) {
	if m.addcompletion_audio_tokens != nil {
		*m.addcompletion_audio_tokens += i
	} else {
		m.addcompletion_audio_tokens = &i
	}
}

// AddedCompletionAudioTokens returns the value that was added to the "completion_audio_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAudioTokens() (r int, exists bool) {
	v := m.addcompletion_audio_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAudioTokens clears the value of the "completion_audio_tokens" field.
func (m *UsageLogMutation) ClearCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAudioTokens] = struct{}{}
}

// CompletionAudioTokensCleared returns if the "completion_audio_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAudioTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAudioTokens]
	return ok
}

// ResetCompletionAudioTokens resets all changes to the "completion_audio_tokens" field.
func (m *UsageLogMutation) ResetCompletionAudioTokens() {
	m.completion_audio_tokens = nil
	m.addcompletion_audio_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAudioTokens)
}

// SetCompletionReasoningTokens sets the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) SetCompletionReasoningTokens(i int) {
	m.completion_reasoning_tokens = &i
	m.addcompletion_reasoning_tokens = nil
}

// CompletionReasoningTokens returns the value of the "completion_reasoning_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionReasoningTokens() (r int, exists bool) {
	v := m.completion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionReasoningTokens returns the old "completion_reasoning_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionReasoningTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionReasoningTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionReasoningTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionReasoningTokens: %w", err)
	}
	return oldValue.CompletionReasoningTokens, nil
}

// AddCompletionReasoningTokens adds i to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) AddCompletionReasoningTokens(i int) {
	if m.addcompletion_reasoning_tokens != nil {
		*m.addcompletion_reasoning_tokens += i
	} else {
		m.addcompletion_reasoning_tokens = &i
	}
}

// AddedCompletionReasoningTokens returns the value that was added to the "completion_reasoning_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionReasoningTokens() (r int, exists bool) {
	v := m.addcompletion_reasoning_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionReasoningTokens clears the value of the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ClearCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	m.clearedFields[usagelog.FieldCompletionReasoningTokens] = struct{}{}
}

// CompletionReasoningTokensCleared returns if the "completion_reasoning_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionReasoningTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionReasoningTokens]
	return ok
}

// ResetCompletionReasoningTokens resets all changes to the "completion_reasoning_tokens" field.
func (m *UsageLogMutation) ResetCompletionReasoningTokens() {
	m.completion_reasoning_tokens = nil
	m.addcompletion_reasoning_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionReasoningTokens)
}

// SetCompletionAcceptedPredictionTokens sets the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionAcceptedPredictionTokens(i int) {
	m.completion_accepted_prediction_tokens = &i
	m.addcompletion_accepted_prediction_tokens = nil
}

// CompletionAcceptedPredictionTokens returns the value of the "completion_accepted_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokens() (r int, exists bool) {
	v := m.completion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionAcceptedPredictionTokens returns the old "completion_accepted_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionAcceptedPredictionTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionAcceptedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionAcceptedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionAcceptedPredictionTokens: %w", err)
	}
	return oldValue.CompletionAcceptedPredictionTokens, nil
}

// AddCompletionAcceptedPredictionTokens adds i to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionAcceptedPredictionTokens(i int) {
	if m.addcompletion_accepted_prediction_tokens != nil {
		*m.addcompletion_accepted_prediction_tokens += i
	} else {
		m.addcompletion_accepted_prediction_tokens = &i
	}
}

// AddedCompletionAcceptedPredictionTokens returns the value that was added to the "completion_accepted_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionAcceptedPredictionTokens() (r int, exists bool) {
	v := m.addcompletion_accepted_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionAcceptedPredictionTokens clears the value of the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens] = struct{}{}
}

// CompletionAcceptedPredictionTokensCleared returns if the "completion_accepted_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionAcceptedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionAcceptedPredictionTokens]
	return ok
}

// ResetCompletionAcceptedPredictionTokens resets all changes to the "completion_accepted_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionAcceptedPredictionTokens() {
	m.completion_accepted_prediction_tokens = nil
	m.addcompletion_accepted_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionAcceptedPredictionTokens)
}

// SetCompletionRejectedPredictionTokens sets the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) SetCompletionRejectedPredictionTokens(i int) {
	m.completion_rejected_prediction_tokens = &i
	m.addcompletion_rejected_prediction_tokens = nil
}

// CompletionRejectedPredictionTokens returns the value of the "completion_rejected_prediction_tokens" field in the mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokens() (r int, exists bool) {
	v := m.completion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionRejectedPredictionTokens returns the old "completion_rejected_prediction_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCompletionRejectedPredictionTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionRejectedPredictionTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionRejectedPredictionTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionRejectedPredictionTokens: %w", err)
	}
	return oldValue.CompletionRejectedPredictionTokens, nil
}

// AddCompletionRejectedPredictionTokens adds i to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) AddCompletionRejectedPredictionTokens(i int) {
	if m.addcompletion_rejected_prediction_tokens != nil {
		*m.addcompletion_rejected_prediction_tokens += i
	} else {
		m.addcompletion_rejected_prediction_tokens = &i
	}
}

// AddedCompletionRejectedPredictionTokens returns the value that was added to the "completion_rejected_prediction_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCompletionRejectedPredictionTokens() (r int, exists bool) {
	v := m.addcompletion_rejected_prediction_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ClearCompletionRejectedPredictionTokens clears the value of the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ClearCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens] = struct{}{}
}

// CompletionRejectedPredictionTokensCleared returns if the "completion_rejected_prediction_tokens" field was cleared in this mutation.
func (m *UsageLogMutation) CompletionRejectedPredictionTokensCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldCompletionRejectedPredictionTokens]
	return ok
}

// ResetCompletionRejectedPredictionTokens resets all changes to the "completion_rejected_prediction_tokens" field.
func (m *UsageLogMutation) ResetCompletionRejectedPredictionTokens() {
	m.completion_rejected_prediction_tokens = nil
	m.addcompletion_rejected_prediction_tokens = nil
	delete(m.clearedFields, usagelog.FieldCompletionRejectedPredictionTokens)
}

// SetSource sets the "source" field.
func (m *UsageLogMutation) SetSource(u usagelog.Source) {
	m.source = &u
}

// Source returns the value of the "source" field in the mutation.
func (m *UsageLogMutation) Source() (r usagelog.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSource(ctx context.Context) (v usagelog.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *UsageLogMutation) ResetSource() {
	m.source = nil
}

// SetFormat sets the "format" field.
func (m *UsageLogMutation) SetFormat(s string) {
	m.format = &s
}

// Format returns the value of the "format" field in the mutation.
func (m *UsageLogMutation) Format() (r string, exists bool) {
	v := m.format
	if v == nil {
		return
	}
	return *v, true
}

// OldFormat returns the old "format" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFormat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormat: %w", err)
	}
	return oldValue.Format, nil
}

// ResetFormat resets all changes to the "format" field.
func (m *UsageLogMutation) ResetFormat() {
	m.format = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usagelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearRequest clears the "request" edge to the Request entity.
func (m *UsageLogMutation) ClearRequest() {
	m.clearedrequest = true
	m.clearedFields[usagelog.FieldRequestID] = struct{}{}
}

// RequestCleared reports if the "request" edge to the Request entity was cleared.
func (m *UsageLogMutation) RequestCleared() bool {
	return m.clearedrequest
}

// RequestIDs returns the "request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) RequestIDs() (ids []int) {
	if id := m.request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequest resets all changes to the "request" edge.
func (m *UsageLogMutation) ResetRequest() {
	m.request = nil
	m.clearedrequest = false
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *UsageLogMutation) ClearChannel() {
	m.clearedchannel = true
	m.clearedFields[usagelog.FieldChannelID] = struct{}{}
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *UsageLogMutation) ChannelCleared() bool {
	return m.ChannelIDCleared() || m.clearedchannel
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) ChannelIDs() (ids []int) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *UsageLogMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usagelog.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, usagelog.FieldUserID)
	}
	if m.request != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.channel != nil {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.model_id != nil {
		fields = append(fields, usagelog.FieldModelID)
	}
	if m.prompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.completion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.total_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.prompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.prompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.completion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.completion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.completion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.completion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	if m.source != nil {
		fields = append(fields, usagelog.FieldSource)
	}
	if m.format != nil {
		fields = append(fields, usagelog.FieldFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	case usagelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagelog.FieldDeletedAt:
		return m.DeletedAt()
	case usagelog.FieldUserID:
		return m.UserID()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldChannelID:
		return m.ChannelID()
	case usagelog.FieldModelID:
		return m.ModelID()
	case usagelog.FieldPromptTokens:
		return m.PromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.CompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.TotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.PromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.PromptCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.CompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.CompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.CompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.CompletionRejectedPredictionTokens()
	case usagelog.FieldSource:
		return m.Source()
	case usagelog.FieldFormat:
		return m.Format()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usagelog.FieldUserID:
		return m.OldUserID(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldChannelID:
		return m.OldChannelID(ctx)
	case usagelog.FieldModelID:
		return m.OldModelID(ctx)
	case usagelog.FieldPromptTokens:
		return m.OldPromptTokens(ctx)
	case usagelog.FieldCompletionTokens:
		return m.OldCompletionTokens(ctx)
	case usagelog.FieldTotalTokens:
		return m.OldTotalTokens(ctx)
	case usagelog.FieldPromptAudioTokens:
		return m.OldPromptAudioTokens(ctx)
	case usagelog.FieldPromptCachedTokens:
		return m.OldPromptCachedTokens(ctx)
	case usagelog.FieldCompletionAudioTokens:
		return m.OldCompletionAudioTokens(ctx)
	case usagelog.FieldCompletionReasoningTokens:
		return m.OldCompletionReasoningTokens(ctx)
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.OldCompletionAcceptedPredictionTokens(ctx)
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.OldCompletionRejectedPredictionTokens(ctx)
	case usagelog.FieldSource:
		return m.OldSource(ctx)
	case usagelog.FieldFormat:
		return m.OldFormat(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagelog.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usagelog.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldChannelID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case usagelog.FieldModelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelID(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionRejectedPredictionTokens(v)
		return nil
	case usagelog.FieldSource:
		v, ok := value.(usagelog.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case usagelog.FieldFormat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormat(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, usagelog.FieldDeletedAt)
	}
	if m.addprompt_tokens != nil {
		fields = append(fields, usagelog.FieldPromptTokens)
	}
	if m.addcompletion_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionTokens)
	}
	if m.addtotal_tokens != nil {
		fields = append(fields, usagelog.FieldTotalTokens)
	}
	if m.addprompt_audio_tokens != nil {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.addprompt_cached_tokens != nil {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.addcompletion_audio_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.addcompletion_reasoning_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.addcompletion_accepted_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.addcompletion_rejected_prediction_tokens != nil {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldDeletedAt:
		return m.AddedDeletedAt()
	case usagelog.FieldPromptTokens:
		return m.AddedPromptTokens()
	case usagelog.FieldCompletionTokens:
		return m.AddedCompletionTokens()
	case usagelog.FieldTotalTokens:
		return m.AddedTotalTokens()
	case usagelog.FieldPromptAudioTokens:
		return m.AddedPromptAudioTokens()
	case usagelog.FieldPromptCachedTokens:
		return m.AddedPromptCachedTokens()
	case usagelog.FieldCompletionAudioTokens:
		return m.AddedCompletionAudioTokens()
	case usagelog.FieldCompletionReasoningTokens:
		return m.AddedCompletionReasoningTokens()
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		return m.AddedCompletionAcceptedPredictionTokens()
	case usagelog.FieldCompletionRejectedPredictionTokens:
		return m.AddedCompletionRejectedPredictionTokens()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	case usagelog.FieldPromptTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptTokens(v)
		return nil
	case usagelog.FieldCompletionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionTokens(v)
		return nil
	case usagelog.FieldTotalTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTokens(v)
		return nil
	case usagelog.FieldPromptAudioTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptAudioTokens(v)
		return nil
	case usagelog.FieldPromptCachedTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPromptCachedTokens(v)
		return nil
	case usagelog.FieldCompletionAudioTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAudioTokens(v)
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionReasoningTokens(v)
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionAcceptedPredictionTokens(v)
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompletionRejectedPredictionTokens(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldChannelID) {
		fields = append(fields, usagelog.FieldChannelID)
	}
	if m.FieldCleared(usagelog.FieldPromptAudioTokens) {
		fields = append(fields, usagelog.FieldPromptAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldPromptCachedTokens) {
		fields = append(fields, usagelog.FieldPromptCachedTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAudioTokens) {
		fields = append(fields, usagelog.FieldCompletionAudioTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionReasoningTokens) {
		fields = append(fields, usagelog.FieldCompletionReasoningTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionAcceptedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionAcceptedPredictionTokens)
	}
	if m.FieldCleared(usagelog.FieldCompletionRejectedPredictionTokens) {
		fields = append(fields, usagelog.FieldCompletionRejectedPredictionTokens)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldChannelID:
		m.ClearChannelID()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ClearPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ClearPromptCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ClearCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ClearCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ClearCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ClearCompletionRejectedPredictionTokens()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usagelog.FieldUserID:
		m.ResetUserID()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldChannelID:
		m.ResetChannelID()
		return nil
	case usagelog.FieldModelID:
		m.ResetModelID()
		return nil
	case usagelog.FieldPromptTokens:
		m.ResetPromptTokens()
		return nil
	case usagelog.FieldCompletionTokens:
		m.ResetCompletionTokens()
		return nil
	case usagelog.FieldTotalTokens:
		m.ResetTotalTokens()
		return nil
	case usagelog.FieldPromptAudioTokens:
		m.ResetPromptAudioTokens()
		return nil
	case usagelog.FieldPromptCachedTokens:
		m.ResetPromptCachedTokens()
		return nil
	case usagelog.FieldCompletionAudioTokens:
		m.ResetCompletionAudioTokens()
		return nil
	case usagelog.FieldCompletionReasoningTokens:
		m.ResetCompletionReasoningTokens()
		return nil
	case usagelog.FieldCompletionAcceptedPredictionTokens:
		m.ResetCompletionAcceptedPredictionTokens()
		return nil
	case usagelog.FieldCompletionRejectedPredictionTokens:
		m.ResetCompletionRejectedPredictionTokens()
		return nil
	case usagelog.FieldSource:
		m.ResetSource()
		return nil
	case usagelog.FieldFormat:
		m.ResetFormat()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.request != nil {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.channel != nil {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeRequest:
		if id := m.request; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.clearedrequest {
		edges = append(edges, usagelog.EdgeRequest)
	}
	if m.clearedchannel {
		edges = append(edges, usagelog.EdgeChannel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeUser:
		return m.cleareduser
	case usagelog.EdgeRequest:
		return m.clearedrequest
	case usagelog.EdgeChannel:
		return m.clearedchannel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ClearUser()
		return nil
	case usagelog.EdgeRequest:
		m.ClearRequest()
		return nil
	case usagelog.EdgeChannel:
		m.ClearChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ResetUser()
		return nil
	case usagelog.EdgeRequest:
		m.ResetRequest()
		return nil
	case usagelog.EdgeChannel:
		m.ResetChannel()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *int
	adddeleted_at     *int
	email             *string
	status            *user.Status
	prefer_language   *string
	password          *string
	first_name        *string
	last_name         *string
	avatar            *string
	is_owner          *bool
	scopes            *[]string
	appendscopes      []string
	clearedFields     map[string]struct{}
	requests          map[int]struct{}
	removedrequests   map[int]struct{}
	clearedrequests   bool
	api_keys          map[int]struct{}
	removedapi_keys   map[int]struct{}
	clearedapi_keys   bool
	roles             map[int]struct{}
	removedroles      map[int]struct{}
	clearedroles      bool
	usage_logs        map[int]struct{}
	removedusage_logs map[int]struct{}
	clearedusage_logs bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(i int) {
	m.deleted_at = &i
	m.adddeleted_at = nil
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r int, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// AddDeletedAt adds i to the "deleted_at" field.
func (m *UserMutation) AddDeletedAt(i int) {
	if m.adddeleted_at != nil {
		*m.adddeleted_at += i
	} else {
		m.adddeleted_at = &i
	}
}

// AddedDeletedAt returns the value that was added to the "deleted_at" field in this mutation.
func (m *UserMutation) AddedDeletedAt() (r int, exists bool) {
	v := m.adddeleted_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	m.adddeleted_at = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetPreferLanguage sets the "prefer_language" field.
func (m *UserMutation) SetPreferLanguage(s string) {
	m.prefer_language = &s
}

// PreferLanguage returns the value of the "prefer_language" field in the mutation.
func (m *UserMutation) PreferLanguage() (r string, exists bool) {
	v := m.prefer_language
	if v == nil {
		return
	}
	return *v, true
}

// OldPreferLanguage returns the old "prefer_language" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPreferLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreferLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreferLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreferLanguage: %w", err)
	}
	return oldValue.PreferLanguage, nil
}

// ResetPreferLanguage resets all changes to the "prefer_language" field.
func (m *UserMutation) ResetPreferLanguage() {
	m.prefer_language = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetIsOwner sets the "is_owner" field.
func (m *UserMutation) SetIsOwner(b bool) {
	m.is_owner = &b
}

// IsOwner returns the value of the "is_owner" field in the mutation.
func (m *UserMutation) IsOwner() (r bool, exists bool) {
	v := m.is_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOwner returns the old "is_owner" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOwner: %w", err)
	}
	return oldValue.IsOwner, nil
}

// ResetIsOwner resets all changes to the "is_owner" field.
func (m *UserMutation) ResetIsOwner() {
	m.is_owner = nil
}

// SetScopes sets the "scopes" field.
func (m *UserMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *UserMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *UserMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *UserMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ClearScopes clears the value of the "scopes" field.
func (m *UserMutation) ClearScopes() {
	m.scopes = nil
	m.appendscopes = nil
	m.clearedFields[user.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *UserMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[user.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *UserMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
	delete(m.clearedFields, user.FieldScopes)
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *UserMutation) AddRequestIDs(ids ...int) {
	if m.requests == nil {
		m.requests = make(map[int]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *UserMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *UserMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *UserMutation) RemoveRequestIDs(ids ...int) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *UserMutation) RemovedRequestsIDs() (ids []int) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *UserMutation) RequestsIDs() (ids []int) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *UserMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int) {
	if m.api_keys == nil {
		m.api_keys = make(map[int]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int) {
	if m.roles == nil {
		m.roles = make(map[int]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int) {
	if m.removedroles == nil {
		m.removedroles = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserMutation) AddUsageLogIDs(ids ...int) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserMutation) RemoveUsageLogIDs(ids ...int) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) RemovedUsageLogsIDs() (ids []int) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserMutation) UsageLogsIDs() (ids []int) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.prefer_language != nil {
		fields = append(fields, user.FieldPreferLanguage)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.is_owner != nil {
		fields = append(fields, user.FieldIsOwner)
	}
	if m.scopes != nil {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPreferLanguage:
		return m.PreferLanguage()
	case user.FieldPassword:
		return m.Password()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldIsOwner:
		return m.IsOwner()
	case user.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPreferLanguage:
		return m.OldPreferLanguage(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldIsOwner:
		return m.OldIsOwner(ctx)
	case user.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPreferLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreferLanguage(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldIsOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOwner(v)
		return nil
	case user.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.adddeleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldDeletedAt:
		return m.AddedDeletedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldDeletedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldScopes) {
		fields = append(fields, user.FieldScopes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldScopes:
		m.ClearScopes()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPreferLanguage:
		m.ResetPreferLanguage()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldIsOwner:
		m.ResetIsOwner()
		return nil
	case user.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.requests != nil {
		edges = append(edges, user.EdgeRequests)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.usage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedrequests != nil {
		edges = append(edges, user.EdgeRequests)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrequests {
		edges = append(edges, user.EdgeRequests)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedusage_logs {
		edges = append(edges, user.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRequests:
		return m.clearedrequests
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRequests:
		m.ResetRequests()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
